FUNCTION_BLOCK "FB_LSZ01_F"
TITLE =%version: 1.10 % CN: 41
//Function: 
//This will control LSZ to store the bags on the configured Gap, emptying the 
//bags on the configured capacity of through put, determining the LSZ status.
//
//History:
//This version  %created_by:  nlhdl %
//              %date_created: Monday, July 09, 2018 12:46:20 PM %
//              %release: VI_RAW/RA_Dev %
//
//Modification History:                                   By:    Date:     Rev:
//----------------------------------------------------  -------  --------  -----
//ra#29138: LSZ01 use section run                       nlHdL    09-07-18   1.10
//bhs_plf#5706: flush stopped by E save upstream        nlHdL    26-02-18   1.09
//bhs_plf#4854: Gap bags not maintained while emptying  nlHdL    08-12-17   1.08
//ra#26873: Add Action Active and remove unused code    inajos   07-12-17   1.07 
//ra#25877: Add minimum H2H                             nldy     30-10-17   1.06
//ra#25877: Process review comments                     nldy     26-10-17   1.05
//bhs_plf#3176: LSZ - Gap between bags is not maintain  nlHdL    13-09-17   1.04
//ra#54234: Rectify s_DB_PLT_Info structure             inajos   19-06-17   1.03
//ra#54187: Align As per Product Book                   inajos   16-06-17   1.02
//ra#18645:Init vs based on vs 1.07 of "FB_LSZ_Control" nlJClo  18-11-2016  1.01
//
//Description:
//- When the bag is at LSZ in-feed section Run out distance, then it will give 
// 'request run' to the LSZ TRS1 until configured gap is fulfilled. This 
//  will be repeatedly continuing until LSZ TRS1 is full.
//- When the Gap is not full filled it will give request disable send for 
//  the upstream section of the LSZ.
//- When the LSZ TRS1 is full, then it will enable TRS2, so that 
//  on 'request run' along with TRS1 & TRS2 also run. This will be 
//  continuing until the last TRS of the LSZ.
//- To avoid the conveyor start-up all together at a time, there is 
//  configurable cascade delay time between the conveyors for start up one after 
//  other.(Note:- It will increase the gap of the baggage when it is handed over 
//  to the next section)
//  LSZ section speed 30Mtr/Min i.e. 50cm/sec, if we configure cascade delay 
//  time is 100ms then in each section baggage Gap is increased by 5cm.  
//- When all the sections in the LSZ are full then it will give status Full.
//- When the Flush command is active, baggages in the LSZ will start 
//  emptying on the configured capacity of through put.
//- When the flush command is active or LSZ full it will not allow any 
//  baggage to the Lane storage zone (Request disable send of the LSZ In-feed 
//  section).
//
//
//
FAMILY : RAW
VERSION : 0.0


VAR_INPUT
  i_DB_PLT_Most_UpStr : BLOCK_DB ;	//Data Structure: Position DataBlock most Upstream section
  i_DB_PLT_Most_DwnStr : BLOCK_DB ;	//Data Structure: Position DataBlock most Downstream section
  i_DB_Event : BLOCK_DB ;	//Data Structure: Event DB
  i_CFG_Gap : INT ;	//CFG: [cm] Gap between the Baggage
  i_CFG_Avg_Bag_Length : INT ;	//CFG: [cm] Average baggage length
  i_CFG_Start_Up_Distance : INT ;	//CFG: [cm] Distance from standstill to nominal speed.
  i_CFG_Run_Out_Distance : INT ;	//CFG: [cm] Run out distance for the section
  i_CFG_Cascade_Delay_Time : INT ;	//CFG: [ms] Cascade delay time
  i_CFG_HLC_Report_Time : INT ;	//CFG: [sec] Periodical HLC reporting time, 0 = Reporting on Status change
  i_CFG_Run_Out_E_S : INT  := 1000;	//CFG: [ms] Run Out Time Energy Saving
  i_CFG_Conveyor_Speed : INT ;	//CFG: [mm/sec] Conveyor Speed
  i_Minimum_H2H : INT ;	//[cm] Minimum head to head length (0 = no head to head control)
  i_LSZ_All_Sec_Started : BOOL ;	//All LSZ section started
  i_CMD_Start_Flush : BOOL ;	//CMD: Start Flush command (One shot pulse)
  i_CMD_Disable_Lane : BOOL ;	//CMD:Disable Lane
  i_CMD_Enable_Lane : BOOL ;	//CMD:Enable Lane
  i_Safety_OK : BOOL  := TRUE;	//Safety is OK signal
  i_Stopped : BOOL ;	//Area Stopped
  i_CFG_PTO : BOOL ;	//Last two sections are PTO
  i_Action_Active : BOOL ;	//Action Active Induct
END_VAR
VAR_OUTPUT
  o_TRS1_CMD_Req_Run : BOOL ;	//CMD: Req run motor TRS1
  o_TRS2_CMD_Req_Run : BOOL ;	//CMD: Req run motor TRS2
  o_TRS3_CMD_Req_Run : BOOL ;	//CMD: Req run motor TRS3
  o_TRS4_CMD_Req_Run : BOOL ;	//CMD: Req run motor TRS4
  o_TRS5_CMD_Req_Run : BOOL ;	//CMD: Req run motor TRS5
  o_TRS6_CMD_Req_Run : BOOL ;	//CMD: Req run motor TRS6
  o_TRS7_CMD_Req_Run : BOOL ;	//CMD: Req run motor TRS7
  o_TRS8_CMD_Req_Run : BOOL ;	//CMD: Req run motor TRS8
  o_LSZ_Dis_Send_Infeed : BOOL ;	//Request disable send of Infeed LSZ (Upstream)
  o_LSZ_Outfeed_Rst_ESave : BOOL ;	//Reset energy save of LSZ outfeed (Downstream)
  o_ST_Operational_On : BOOL ;	//ST: Operational ON
  o_ST_LSZ_Empty : BOOL ;	//ST: LSZ Empty
  o_ST_LSZ_Full : BOOL ;	//ST: LSZ full
  o_ST_LSZ_Emptying : BOOL ;	//ST: Emptying the bags
  o_ST_Lane_Disabled : BOOL ;	//Lane is Disabled
  o_Enable_Release_Req : BOOL ;	//Enable Release Request
  o_TEP : INT ;	//Zone Total Empty Positions 
  o_TOP : INT ;	//Zone Total Occupied Positions 
END_VAR
VAR
  s_FB_Flow_control : "FB_Flow_Control";	//control the output of the baggage flow 
  s_DB_PLT_Info : ARRAY  [1 .. 8 ] OF //Info of used PLT DB's for window generator
  STRUCT 	
   DB_PLT_Number : INT ;	//Number of PLT DB
   DB_PLT_Number_Downstream : INT ;	//Number of downstream PLT DB
   DB_PLT_Number_Upstream : INT ;	//Number of upstream PLT DB
   Conveyor_Length : INT ;	//Conveyor length of PLT DB
   Conveyor_Run : BOOL  := TRUE;	//Conveyor is running
  END_STRUCT ;	
  s_Item_Info : ARRAY  [1 .. 10 ] OF //Item Info
  STRUCT 	
   Position : INT ;	//PLT Position where Data is Found
   Info : INT ;	//Info Found in PLT DB
   Data : INT ;	//Link found in PLT DB
   DB_PLT : INT ;	//PLT DB Number
   Number_Items_Found : INT ;	//Number of Items Found
  END_STRUCT ;	
  s_Total_Conveyor_Length : DINT ;	//Total length of all conveyors used for window generating
  s_Abs_Pos_First_Item : DINT ;	//Absolute position first item in the LSZ
  s_info_Set_Req_Run : INT ;	//Info to set the Request Run
  s_info_Reset_Req_Run : INT ;	//Info to Reset the Request Run
  s_TRS1_Start_Delay_Time : INT ;	//TRS1 start delay time
  s_TRS2_Start_Delay_Time : INT ;	//TRS2 start delay time
  s_TRS3_Start_Delay_Time : INT ;	//TRS3 start delay time
  s_TRS4_Start_Delay_Time : INT ;	//TRS4 start delay time
  s_TRS5_Start_Delay_Time : INT ;	//TRS5 start delay time
  s_TRS6_Start_Delay_Time : INT ;	//TRS6 start delay time
  s_TRS7_Start_Delay_Time : INT ;	//TRS1 start delay time
  s_HLC_Report_Time : INT ;	//Counter for the Status reporting to Event-DB
  s_Prev_Segment_State : INT ;	//Memory of the previous reported Segment state
  s_Info_Loop_Nr : INT ;	//Loop number for used PLT info search
  s_DB_PLT_nr_Most_Downst : INT ;	//DB PLT number of the upstream conveyor
  s_Window_Length : INT ;	//Calculated window length
  s_Num_of_Sections : INT ;	//Number of sections in the zone
  s_Run_Out_Distanc_E_Save : INT ;	//[cm] Run out distance after handover, before conveyor goes in energy saving
  s_Most_Down_Con_Len : INT ;	//Most Downstream Conveyor Length
  s_Most_Down_Lead_Found : INT ;	//Most Downstream Conveyor Leading Edge Found
  s_Most_Down_Trail_Found : INT ;	//Most Downstream Conveyor Trailing Edge Found
  s_TimeSpoint_AvaiRep : INT ;	//Setpoint Time for Avail report
  s_Most_Down_Mtr_Run : BOOL ;	//Most Downstream Motor Run
  s_FP_Down_Esave_Run : BOOL ;	//Positive Flank For One conveyor length Esave
  s_Request_Run : BOOL ;	//Request run
  s_FN_info_Reset_Req_Run : BOOL ;	//Negative Flank of Info to reset the Request run
  s_TRS1_Activate : BOOL ;	//Activate TRS1
  s_TRS2_Activate : BOOL ;	//Activate TRS2
  s_TRS3_Activate : BOOL ;	//Activate TRS3
  s_TRS4_Activate : BOOL ;	//Activate TRS4
  s_TRS5_Activate : BOOL ;	//Activate TRS5
  s_TRS6_Activate : BOOL ;	//Activate TRS6
  s_TRS7_Activate : BOOL ;	//Activate TRS7
  s_TRS8_Activate : BOOL ;	//Activate TRS8
  s_TRS1_Start_Delay_Ok : BOOL ;	//TRS1 start delay done
  s_TRS2_Start_Delay_Ok : BOOL ;	//TRS2 start delay done
  s_TRS3_Start_Delay_Ok : BOOL ;	//TRS3 start delay done
  s_TRS4_Start_Delay_Ok : BOOL ;	//TRS4 start delay done
  s_TRS5_Start_Delay_Ok : BOOL ;	//TRS5 start delay done
  s_TRS6_Start_Delay_Ok : BOOL ;	//TRS6 start delay done
  s_TRS7_Start_Delay_Ok : BOOL ;	//TRS7 start delay done
  s_FN_Flush_Memory : BOOL ;	//Flush memory
  s_FN_Flush : BOOL ;	//Negative Flank Flush memory
  s_FP_Flush_Memory : BOOL ;	//Flush memory
  s_FP_Flush : BOOL ;	//Positive Flank Flush memory
  s_Start_Req_Run : BOOL ;	//Bag noticed in Infeed EOS Start Request to Run
  s_FN_Stop_Req_Run : BOOL  := TRUE;	//Bag is stored Stop request to run
  s_Infeed_HandOvr_Fault : BOOL ;	//Flush command & Handover is active
  s_Flush_Req_Run : BOOL ;	//Request run from Flush command or Semi-Auto
  s_Start_Flush_Memory : BOOL ;	//Flush command memory (To start the emptying process)
  s_LSZ_Full : BOOL ;	//Static memory for LSZ full
  s_Infeed_Handover_Active : BOOL ;	//Infeed section Handover is active
  s_HLC_Report_Time_Active : BOOL ;	//Memory HLC report time expires
  s_FN_Operation_On : BOOL ;	//Negative Flank of the Operational On
  s_FP_LSZ_Full : BOOL ;	//Positive Flank of the LSZ FULL
  s_FP_LSZ_Emptying : BOOL ;	//Positive Flank of the Emptying (Flushing)
  s_FP_Operation_On : BOOL ;	//Positive Flank of the Operational On
  s_Downstream_PLT_NotUsed : BOOL ;	//Upstream PLT is not used for loop search PLT info
  s_Done : BOOL ;	//Bit to indicate that pointer calculation has been done
  s_FN_TRS1_Info_1 : BOOL ;	//detection negative flank info 1 present in PLT
  s_FN_TRS2_Info_1 : BOOL ;	//detection negative flank info 1 present in PLT
  s_FN_TRS3_Info_1 : BOOL ;	//detection negative flank info 1 present in PLT
  s_FN_TRS4_Info_1 : BOOL ;	//detection negative flank info 1 present in PLT
  s_FN_TRS5_Info_1 : BOOL ;	//detection negative flank info 1 present in PLT
  s_FN_TRS6_Info_1 : BOOL ;	//detection negative flank info 1 present in PLT
  s_FN_TRS7_Info_1 : BOOL ;	//detection negative flank info 1 present in PLT
  s_FN_TRS8_Info_1 : BOOL ;	//detection negative flank info 1 present in PLT
  s_FP_Flush_Mem : BOOL ;	//FP Flush memory
  s_Disable_Error : BOOL ;	//Disable Error
  s_FN_Disable : BOOL ;	//Negative Flank Disable
  s_Disable_Command : BOOL ;	//Disable Command
  s_FP_Operational_Active : BOOL ;	//Positive Flank Operational
  s_FN_Operational_Active : BOOL ;	//Negative Flank Operational
  s_Time_Elapsed_AvaiRep : BOOL ;	//Timer Elapsed Availability Report
  s_Stopped : BOOL ;	//Stopped
  s_FN_Disable_Command : BOOL ;	//Negative Flank Disable Command
END_VAR
VAR_TEMP
  t_AR2_Mask : DWORD ;	//'relative address' mask
  t_Info_last_Sec : INT ;	//Info of Last section
  t_TRS1_Info : INT ;	//Info of TRS1
  t_TRS2_Info : INT ;	//Info of TRS2
  t_TRS3_Info : INT ;	//Info of TRS3
  t_TRS4_Info : INT ;	//Info of TRS4
  t_TRS5_Info : INT ;	//Info of TRS5
  t_TRS6_Info : INT ;	//Info of TRS6
  t_TRS7_Info : INT ;	//Info of TRS7
  t_TRS8_Info : INT ;	//Info of TRS8
  t_Not_Used_Int : INT ;	//Dummy Integer which is not used.
  t_Infeed_Num_Items_Found : INT ;	//Number of Items found in Infeed EOS
  t_EBS_Lane_State : INT ;	//EBS Lane State
  t_Return_Value : INT ;	//Return value of the FC_Write_Event
  t_DB_Event_Num : INT ;	//DB_Event Number
  t_Loaded_PLT : INT ;	//Current loaded PLT DB number for loop search function
  t_Most_Downstream_PLT_NO : INT ;	//Most downstream PLT number
  t_Most_Upstream_PLT_NO : INT ;	//Most upnstream PLT number
  t_TRS1_Items_Present : INT ;	//Item present at conveyor 1
  t_TRS2_Items_Present : INT ;	//Item present at conveyor 2
  t_TRS3_Items_Present : INT ;	//Item present at conveyor 3
  t_TRS4_Items_Present : INT ;	//Item present at conveyor 4
  t_TRS5_Items_Present : INT ;	//Item present at conveyor 5
  t_TRS6_Items_Present : INT ;	//Item present at conveyor 6
  t_TRS7_Items_Present : INT ;	//Item present at conveyor 7
  t_TRS8_Items_Present : INT ;	//Item present at conveyor 8
  t_Upstream_Of_LSZ_PLT_DB : INT ;	//Upstream of LSZ PLT DB
  t_TRS1_Inf_E_S : INT ;	//Info -3 present in PLT
  t_TRS2_Inf_E_S : INT ;	//Info -3 present in PLT
  t_TRS3_Inf_E_S : INT ;	//Info -3 present in PLT
  t_TRS4_Inf_E_S : INT ;	//Info -3 present in PLT
  t_TRS5_Inf_E_S : INT ;	//Info -3 present in PLT
  t_TRS6_Inf_E_S : INT ;	//Info -3 present in PLT
  t_TRS7_Inf_E_S : INT ;	//Info -3 present in PLT
  t_TRS8_Inf_E_S : INT ;	//Info -3 present in PLT
  t_Available_Value : INT ;	//Available Status
  t_Run_out_Dist_InF : INT ;	//Run out distance of infeed before item
  t_Upstream_DB_Num : INT ;	//UPstream section db number
  t_Window_Full : INT ;	//Window to check if LSZ is considered full
  t_Conveyor_Speed : INT ;	//Conveyor speed used for flow control
  t_OS_FP_Oper_Active : BOOL ;	//Positive Edge Operational
  t_OS_FN_Oper_Active : BOOL ;	//Negative Edge Operational
  t_StartTimerModereq : BOOL ;	//Start Timer
  t_Last_Sec_Motor_Run : BOOL ;	//Motor Status of the last section
  t_Flow_Ok : BOOL ;	//Flow ok
  t_Not_Used_bool : BOOL ;	//Dummy Bool which is not used.
  t_Item_At_Handover_Upstr : BOOL ;	//Item at Handover position 
  t_Item_Entering_LSZ_InHO : BOOL ;	//Item entering the LSZ is in HandOver
  t_OS_Flush_Memory : BOOL ;	//One shot positive flank flush memory
  t_Upstream_Section_oper : BOOL ;	//Upstream section operational
END_VAR
BEGIN
NETWORK
TITLE =AA: Obtain relative address from AR2
//Address register:      10000ZZZ 00000yyy yyyyyyyy yyyyyxxx
//                 Z=Operand area      y=Byte address    x=Bit address
//Mask Byte and Bit address only
      TAR2  ; // Load 'base address register' 
      AD    DW#16#FFFFFF; // Mask 'address only' out of area-internal-pointer
      T     #t_AR2_Mask; // 'relative address'-mask

      A     "M_First_Scan"; 
      JCN   AA01; 
      CLR   ; 
      =     #s_Disable_Error; 

AA01: NOP   0; 
NETWORK
TITLE =BA: Determine Initial variables

      OPN   #i_DB_Event; 
      L     DBNO; // Load Event PLT DB number
      T     #t_DB_Event_Num; // Transfer Event PLT DB number to temp

      CLR   ; 
      =     #t_Item_Entering_LSZ_InHO; 

      OPN   #i_DB_PLT_Most_UpStr; // ELSE Most upstream is loaded as first PLT for generator
      L     DBNO; 
      T     #s_DB_PLT_Info[1].DB_PLT_Number; 
      T     #t_Most_Upstream_PLT_NO; 

      OPN   #i_DB_PLT_Most_DwnStr; // Open Most Downstream PLT DB number 
      L     DBNO; 
      T     #s_DB_PLT_nr_Most_Downst; // Store as last PLT number for PLT loop detection end
      T     #t_Most_Downstream_PLT_NO; 

      L     DBW   12; 
      T     #s_Most_Down_Con_Len; 

      A     DBX   10.1; //Downstream Motor Run
      =     #s_Most_Down_Mtr_Run; 

      L     #s_DB_PLT_nr_Most_Downst; // Set Downstream PLT not used when Most upstream PLT DB is not configured
      L     1; 
      <=I   ; 
      =     #s_Downstream_PLT_NotUsed; 

//Calculation OS start flush memory
      A     #s_Start_Flush_Memory; 
      FP    #s_FP_Flush_Mem; 
      =     #t_OS_Flush_Memory; 

//Calculation run out energy save (conv.not active) when flush      
      L     #i_CFG_Run_Out_E_S; // Load common setting run out time for E-save
      L     #i_CFG_Conveyor_Speed; // Load speed setting
      *D    ; 
      L     10000; // Convert mm -> cm AND msec -> sec 10*1000 = 10000
      /D    ; 
      T     #s_Run_Out_Distanc_E_Save; // Run out distance in [cm] 
NETWORK
TITLE =CA: Loop for all DB PLT information in generating area
//All the PLT DB's starting from the most upstream PLT DB till the most downstream
// 
//PLT DB are scanned for there PLT number, downstream PLT number, conveyor length 
//end Conveyor run signal. This can be done for a maximum of 8 PLT DB's. When the
//most downstream PLT DB number is found or the next downsstream PLT number is 
//invalid, the search will be ended. When this search loop exceeds the storage 
//array (configured for 8 PLT DB's), the PLC will be forced to stop. For using 
//the 
//LSZ over 8 PLT DB's the array should be extended. When extending 
//the array the maximum array number must be set correctly at the loop number 
//check at the end of this network.
      L     P##s_DB_PLT_Info; // Create pointer for PLT DB info array
      L     #t_AR2_Mask; // 'relative address'-mask
      +D    ; 
      LAR1  ; 

      SET   ; 
      =     #s_Done; 

      L     0; 
      T     #s_Total_Conveyor_Length; // Initialize with zero
      T     #s_Info_Loop_Nr; // Initialize with zero

CA01: L     W [AR1,P#0.0]; // Load PLT DB number from current array position
      T     #t_Loaded_PLT; 

      OPN   DB [#t_Loaded_PLT]; // Open current PLT DB

      L     DBW    8; // Store Downstream PLT DB number in current info array
      T     W [AR1,P#2.0]; 

      L     DBW    6; // Store Upstream PLT DB number in current info array
      T     W [AR1,P#4.0]; 

      L     DBW   12; // Store conveyor length in current info array
      T     W [AR1,P#6.0]; 

      A     DBX   10.1; // Store conveyor run signal in current info array
      =      [AR1,P#8.0]; 

      L     #s_Total_Conveyor_Length; // Add current conveyor length to total
      L     W [AR1,P#6.0]; 
      +I    ; 
      T     #s_Total_Conveyor_Length; 

      ON    #s_Downstream_PLT_NotUsed; // End Loop search function for next PLT DB when downstream is not used
      JCN   CA99; 

      L     #t_Loaded_PLT; // ELSE compare current PLT DB number
      L     #s_DB_PLT_nr_Most_Downst; // with most downstream PLT DB number
      <>I   ; 
      JCN   CA99; // If equal downstream PLT DB has reached and loop can be ended

      L     W [AR1,P#2.0]; // IF downstream PLT DB number is legal
      L     1; 
      >I    ; 
      JCN   CA99; 

      L     W [AR1,P#2.0]; // THEN copy Downstream PLT DB number to next array
      T     W [AR1,P#10.0]; 

      +AR1  P#10.0; // Raise DB_PLT info pointer to next array

      L     #s_Info_Loop_Nr; // Raise loop number with one
      L     1; 
      +I    ; 
      T     #s_Info_Loop_Nr; 
      L     8; // Load configured loop number. This should be equal with the array length
      >=I   ; // Compare new loop number with maximum array length
      JCN   CA01; // Jump for next PLT DB check

      CALL "STP" ;// PLC Stop! The PLT DB Info array must be extended when the generator is
      NOP   0; // is configured for more then 8 conveyor belts (see also network comment)

CA99: NOP   0; 
NETWORK
TITLE =DA: Determining Operational ON 
//If all the sections are started in the LSZ then it will set the Operational ON.
//
      AN    #s_Disable_Error; 
      AN    #s_Disable_Command; 
      AN    #i_Stopped; 
      S     #o_ST_Operational_On; 

      A     #s_Disable_Error; 
      O     #s_Disable_Command; 
      O     #i_Stopped; 
      AN    #i_Action_Active; 
      R     #o_ST_Operational_On; 
NETWORK
TITLE =EA: Handling Request Run
//If bag is available on the in-feed section Run out distance of the lane storage 
//zone it will set the "Request Run", after bag is travelled until configured gap 
//it will Reset the "Request Run".
//When there is a Baggage in configured Gap window and when new baggage arrived 
//at 
//the In-feed section Run-out distance then Request upstream to Disable Send.
      NOP   0; 

      L     #s_DB_PLT_Info[1].DB_PLT_Number; // If section PLT-DB is zero jump to end of the network
      L     1; 
      >I    ; 
      JCN   EA99; 

//--- Handling the Stop Request Run motor --------//
//-----When trailing edge of the Baggage is leaving the configured Gap window then stop the Request Run Motor    

      CALL "FC_PLT_Srch_Inf_Dwn" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[1].DB_PLT_Number,
           i_Position               := #s_DB_PLT_Info[1].Conveyor_Length,
           i_Window                 := #i_CFG_Gap,
           i_Info                   := 2,
           o_Position               := #t_Not_Used_Int,
           o_Info                   := #s_info_Reset_Req_Run,
           o_LNK                    := #t_Not_Used_Int,
           o_DB_PLT_Num             := #t_Not_Used_Int,
           o_Number_Items_Found     := #t_Not_Used_Int);


//check for section operational

      OPN   #i_DB_PLT_Most_UpStr; 
      L     DBW    6; // section operational
      T     #t_Upstream_DB_Num; 

      OPN   DB [#t_Upstream_DB_Num]; 
      A     DBX   10.5; 
      =     #t_Upstream_Section_oper; 

      A(    ; 
      L     #s_info_Reset_Req_Run; 
      L     2; 
      ==I   ; 
      )     ; 
      FN    #s_FN_info_Reset_Req_Run; 
      =     #s_FN_Stop_Req_Run; //Request to Stop the LSZ sections Motor
//--- Handling the Start Request run motor --------//
//---Searchin in upstream from the begining of the start section until Runout distance, if a leading edge is found then Activate "Request Run"

      L     #i_CFG_Start_Up_Distance; //Start distance on infeed before TRS1 is running
      L     #i_CFG_Run_Out_Distance; 
      +I    ; 
      T     #t_Run_out_Dist_InF; 
//Add extra offset to the run out of the infeed conveyor
      CALL "FC_PLT_Srch_Inf_Dwn" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[1].DB_PLT_Number_Upstream,
           i_Position               := #t_Run_out_Dist_InF,
           i_Window                 := #t_Run_out_Dist_InF,
           i_Info                   := 1,
           o_Position               := #t_Not_Used_Int,
           o_Info                   := #s_info_Set_Req_Run,
           o_LNK                    := #t_Not_Used_Int,
           o_DB_PLT_Num             := #t_Not_Used_Int,
           o_Number_Items_Found     := #t_Not_Used_Int);

      OPN   DB [#t_Most_Upstream_PLT_NO]; 
      A     DBX   10.6; 
      =     #t_Item_At_Handover_Upstr; 

      L     DBW    6; 
      T     #t_Upstream_Of_LSZ_PLT_DB; 

      OPN   DB [#t_Upstream_Of_LSZ_PLT_DB]; 
      A     DBX   10.6; 
      =     #t_Item_Entering_LSZ_InHO; 

      A(    ; 
      L     #s_info_Set_Req_Run; 
      L     1; 
      ==I   ; 
      )     ; 
      O     #t_Item_Entering_LSZ_InHO; 
      =     #s_Start_Req_Run; //Request to Start the LSZ sections Motor  

//Reset the Request run
//-----SET>>>>>>Request Run--
      A     #s_Start_Req_Run; //IF Request start from the Infeed section when the bag is in the Run-out distance
      O     #s_Flush_Req_Run; //IF Flush command
      S     #s_Request_Run; 

//-----RESET>>>>>>Request Run--
      A     #s_FN_Flush_Memory; //set on Negative edge flush Memory
      O(    ; 
      A     #s_FN_Stop_Req_Run; //IF Request stop from the Infeed section when the bag is travelled configured gap
      )     ; 
      O(    ; 
      A     #s_Start_Flush_Memory; //IF Flush command active
      AN    #s_Flush_Req_Run; //IF Flush command 
      )     ; 
      O(    ; 
      AN    #o_ST_LSZ_Emptying; 
      AN    #t_Upstream_Section_oper; 
      )     ; 
      O(    ; 
      AN    #o_ST_LSZ_Emptying; //If LSZ Full & Not emptying
      A(    ; 
      A     #s_LSZ_Full; 
      AN    #i_CFG_PTO; 
      )     ; 
      )     ; 
      R     #s_Request_Run; //Reset the Request run   

//---------Request Disable send to upstream of LSZ-------//
//--When there is a Baggage in configured Gap window & when new baggage arrived at the
//--Infeed section Run-out distance then Request upstream to Disable Send.

      L     #s_info_Reset_Req_Run; 
      L     0; 
      >I    ; 
      AN    #s_Infeed_HandOvr_Fault; //Handover Active of the Infeed section
      =     #o_LSZ_Dis_Send_Infeed; 

EA99: NOP   0; 
NETWORK
TITLE =FA: Handling TRS1
//TRS1 will run without cascade delay, if TRS2 is not activated.
//If TRS2 is activated then TRS1 will run after cascade delay time 
//expires.
//If Request run is active then command to Run TRS1
      L     #s_DB_PLT_Info[1].DB_PLT_Number; // If section PLT-DB is zero jump to end of the network
      L     1; 
      >I    ; 
      JCN   FA99; 

//When Flush action is initiate conveyor runs one conveyor length
      A     #t_OS_Flush_Memory; 
      JCN   FA10; 

      CALL "FC_PLT_Write" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[1].DB_PLT_Number,
           i_Position               := #s_DB_PLT_Info[1].Conveyor_Length,
           i_Info_State             := W#16#0,
           i_Info_Physical          := -3,
           i_LNK                    := 0,
           i_DB_Event_Num           := #t_DB_Event_Num);

FA10: NOP   0; 

// Run out energy saving (conveyor not active) during flush 
      CALL "FC_PLT_Srch_Inf_Dwn" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[1].DB_PLT_Number,
           i_Position               := #s_DB_PLT_Info[1].Conveyor_Length,
           i_Window                 := #s_DB_PLT_Info[1].Conveyor_Length,
           i_Info                   := 1,
           o_Position               := #t_Not_Used_Int,
           o_Info                   := #t_TRS1_Info,
           o_LNK                    := #t_Not_Used_Int,
           o_DB_PLT_Num             := #t_Not_Used_Int,
           o_Number_Items_Found     := #t_Not_Used_Int);

// Detection the last info 1 present in the PLT, means last baggage is in handover to downstream
      L     #t_TRS1_Info; 
      L     1; 
      ==I   ; 
      FN    #s_FN_TRS1_Info_1; 
      JCN   FA01; 

      CALL "FC_PLT_Write" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[1].DB_PLT_Number,
           i_Position               := #s_Run_Out_Distanc_E_Save,
           i_Info_State             := W#16#0,
           i_Info_Physical          := -3,
           i_LNK                    := 0,
           i_DB_Event_Num           := #t_DB_Event_Num);

FA01: NOP   0; 

      CALL "FC_PLT_Srch_Inf_Up" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[1].DB_PLT_Number,
           i_Position               := #s_DB_PLT_Info[1].Conveyor_Length,
           i_Window                 := #i_CFG_Run_Out_Distance,
           i_Info                   := 1,
           o_Position               := #t_Not_Used_Int,
           o_Info                   := #t_TRS1_Info,
           o_LNK                    := #t_Not_Used_Int,
           o_DB_PLT_Num             := #t_Not_Used_Int,
           o_Number_Items_Found     := #t_Not_Used_Int);

      CALL "FC_PLT_Srch_Inf_Dwn" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[1].DB_PLT_Number,
           i_Position               := #s_DB_PLT_Info[1].Conveyor_Length,
           i_Window                 := #s_DB_PLT_Info[1].Conveyor_Length,
           i_Info                   := -3,
           o_Position               := #t_Not_Used_Int,
           o_Info                   := #t_TRS1_Inf_E_S,
           o_LNK                    := #t_Not_Used_Int,
           o_DB_PLT_Num             := #t_Not_Used_Int,
           o_Number_Items_Found     := #t_Not_Used_Int);

// Activation of the TRS1
      A(    ; // IF leading edge(1) is found on the search window
      L     #t_TRS1_Info; 
      L     1; 
      ==I   ; 
      )     ; 
      O(    ; 
      L     #s_Item_Info[1].Number_Items_Found; // OR Section not empty
      L     0; 
      >I    ; 
      )     ; 
      O(    ; 
      L     #t_TRS1_Inf_E_S; 
      L     -3; 
      ==I   ; 
      )     ; 
      =     #s_TRS1_Activate; //THEN Activate the Section

//Check Die-Back during Flush, If downstream not running stop request
      AN    #s_DB_PLT_Info[2].Conveyor_Run; 
      A(    ; 
      L     #s_Item_Info[2].Number_Items_Found; 
      L     0; 
      >I    ; 
      )     ; 
      A     #s_Start_Flush_Memory; 
      R     #s_TRS1_Activate; 

//---Handling the Request Run 
      A     #s_Request_Run; 
      A     #s_TRS1_Activate; 
      =     #o_TRS1_CMD_Req_Run; 
      JCN   FA99; 

//--------------Cascade delay---------------//
      A     #s_TRS2_Activate; 
      AN    #o_TRS2_CMD_Req_Run; 
      JCN   FA02; 

      L     #i_CFG_Cascade_Delay_Time; // load start-up delay
      T     #s_TRS1_Start_Delay_Time; // Transfer to memory

FA02: L     #s_TRS1_Start_Delay_Time; // Then count down the start-up delay
      L     "MW_Prev_Cycle_Time"; // Previous cycle time in Msec
      -I    ; 
      JPZ   FA03; // If below zero, then set back at zero
      L     0; 
FA03: T     #s_TRS1_Start_Delay_Time; 

      L     #s_TRS1_Start_Delay_Time; // If the delay time is zero
      L     0; 
      <=I   ; 
      JCN   FA04; //If it more than zero than jump to the label

      SET   ; // Then cascade delay is done ready to run the motor
      =     #s_TRS1_Start_Delay_Ok; 
      JU    FA05; 

FA04: CLR   ; 
      =     #s_TRS1_Start_Delay_Ok; // Motor is not ready to run  


FA05: A     #s_Request_Run; // Request Run
      A     #s_TRS1_Start_Delay_Ok; //Cascade delay is ok
      =     #o_TRS1_CMD_Req_Run; //Then run the TRS1

FA99: NOP   0; 
NETWORK
TITLE =GA: Handling TRS2
//If there is bag available on TRS1 run out distance then activate the 
//TRS2.
//TRS2 will run without cascade delay, if TRS3 is not activated.
//If TRS3 is activated then TRS2 will run after cascade delay time 
//expires.
//If Request run is active and section 2 is activated then command to Run section
//-2
      L     #s_DB_PLT_Info[2].DB_PLT_Number; // If section PLT-DB is zero jump to end of the network
      L     1; 
      >I    ; 
      JCN   GA99; 

//When Flush action is initiate conveyor runs one conveyor length
      A     #t_OS_Flush_Memory; 
      JCN   GA10; 

      CALL "FC_PLT_Write" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[2].DB_PLT_Number,
           i_Position               := #s_DB_PLT_Info[2].Conveyor_Length,
           i_Info_State             := W#16#0,
           i_Info_Physical          := -3,
           i_LNK                    := 0,
           i_DB_Event_Num           := #t_DB_Event_Num);

GA10: NOP   0; 
// Run out energy saving (conveyor not active) during flush 
      CALL "FC_PLT_Srch_Inf_Dwn" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[2].DB_PLT_Number,
           i_Position               := #s_DB_PLT_Info[2].Conveyor_Length,
           i_Window                 := #s_DB_PLT_Info[2].Conveyor_Length,
           i_Info                   := 1,
           o_Position               := #t_Not_Used_Int,
           o_Info                   := #t_TRS2_Info,
           o_LNK                    := #t_Not_Used_Int,
           o_DB_PLT_Num             := #t_Not_Used_Int,
           o_Number_Items_Found     := #t_Not_Used_Int);

// Detection the last info 1 present in the PLT, means last baggage is in handover to downstream
      L     #t_TRS2_Info; 
      L     1; 
      ==I   ; 
      FN    #s_FN_TRS2_Info_1; 
      JCN   GA01; 

      CALL "FC_PLT_Write" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[2].DB_PLT_Number,
           i_Position               := #s_Run_Out_Distanc_E_Save,
           i_Info_State             := W#16#0,
           i_Info_Physical          := -3,
           i_LNK                    := 0,
           i_DB_Event_Num           := #t_DB_Event_Num);

GA01: NOP   0; 
//- searching-up from the begining of the section until Runout distance, if a leading edge is found then Activate the Section
      CALL "FC_PLT_Srch_Inf_Up" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[2].DB_PLT_Number,
           i_Position               := #s_DB_PLT_Info[2].Conveyor_Length,
           i_Window                 := #i_CFG_Gap,
           i_Info                   := 1,
           o_Position               := #t_Not_Used_Int,
           o_Info                   := #t_TRS2_Info,
           o_LNK                    := #t_Not_Used_Int,
           o_DB_PLT_Num             := #t_Not_Used_Int,
           o_Number_Items_Found     := #t_Not_Used_Int);

      CALL "FC_PLT_Srch_Inf_Dwn" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[2].DB_PLT_Number,
           i_Position               := #s_DB_PLT_Info[2].Conveyor_Length,
           i_Window                 := #s_DB_PLT_Info[2].Conveyor_Length,
           i_Info                   := -3,
           o_Position               := #t_Not_Used_Int,
           o_Info                   := #t_TRS2_Inf_E_S,
           o_LNK                    := #t_Not_Used_Int,
           o_DB_PLT_Num             := #t_Not_Used_Int,
           o_Number_Items_Found     := #t_Not_Used_Int);

// Activation of the TRS2
      A(    ; // IF leading edge(1) is found on the search window
      L     #t_TRS2_Info; 
      L     1; 
      ==I   ; 
      )     ; 
      O(    ; 
      L     #s_Item_Info[2].Number_Items_Found; // OR Section not empty
      L     0; 
      >I    ; 
      )     ; 
      O(    ; 
      L     #t_TRS2_Inf_E_S; 
      L     -3; 
      ==I   ; 
      )     ; 
      =     #s_TRS2_Activate; //THEN Activate the Section

//Check Die-Back during Flush, If downstream not running stop request
      AN    #s_DB_PLT_Info[3].Conveyor_Run; 
      A(    ; 
      L     #s_Item_Info[3].Number_Items_Found; 
      L     0; 
      >I    ; 
      )     ; 
      A     #s_Start_Flush_Memory; 
      R     #s_TRS2_Activate; 

//---Handling the Request Run 
      A     #s_Request_Run; 
      A     #s_TRS2_Activate; 
      =     #o_TRS2_CMD_Req_Run; 
      JCN   GA99; 

//--------------Cascade delay---------------// 

      A     #s_TRS3_Activate; 
      AN    #o_TRS3_CMD_Req_Run; 
      JCN   GA02; 

      L     #i_CFG_Cascade_Delay_Time; // Load the start-up delay
      T     #s_TRS2_Start_Delay_Time; // transfer to the memory


GA02: L     #s_TRS2_Start_Delay_Time; // Then count down the start-up delay
      L     "MW_Prev_Cycle_Time"; 
      -I    ; 
      JPZ   GA03; // If below zero, then set back at zero
      L     0; 
GA03: T     #s_TRS2_Start_Delay_Time; 

      L     #s_TRS2_Start_Delay_Time; // If the delay time is zero
      L     0; 
      <=I   ; 
      JCN   GA04; //If it more than zero than jump to the label

      SET   ; // Then cascade delay is done ready to run the motor
      =     #s_TRS2_Start_Delay_Ok; 
      JU    GA05; 

GA04: CLR   ; 
      =     #s_TRS2_Start_Delay_Ok; // Motor is not ready to run    

GA05: A     #s_Request_Run; // Request Run
      A     #s_TRS2_Start_Delay_Ok; // Cascade delay ok
      =     #o_TRS2_CMD_Req_Run; // Then Run the TRS2 

GA99: NOP   0; 
NETWORK
TITLE =HA: Handling TRS3
//If there is bag available on TRS2 run out distance then activate the 
//TRS3.
//TRS3 will run without cascade delay, if TRS4 is not activated.
//If TRS4 is activated then TRS3 will run after cascade delay time 
//expires.
//If Request run is active and section 3 is activated then command to Run section
//-3
      L     #s_DB_PLT_Info[3].DB_PLT_Number; // If section PLT-DB is zero jump to end of the network
      L     1; 
      >I    ; 
      JCN   HA99; 

//When Flush action is initiate conveyor runs one conveyor length
      A     #t_OS_Flush_Memory; 
      JCN   HA10; 

      CALL "FC_PLT_Write" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[3].DB_PLT_Number,
           i_Position               := #s_DB_PLT_Info[3].Conveyor_Length,
           i_Info_State             := W#16#0,
           i_Info_Physical          := -3,
           i_LNK                    := 0,
           i_DB_Event_Num           := #t_DB_Event_Num);

HA10: NOP   0; 
// Run out energy saving (conveyor not active) during flush 
      CALL "FC_PLT_Srch_Inf_Dwn" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[3].DB_PLT_Number,
           i_Position               := #s_DB_PLT_Info[3].Conveyor_Length,
           i_Window                 := #s_DB_PLT_Info[3].Conveyor_Length,
           i_Info                   := 1,
           o_Position               := #t_Not_Used_Int,
           o_Info                   := #t_TRS3_Info,
           o_LNK                    := #t_Not_Used_Int,
           o_DB_PLT_Num             := #t_Not_Used_Int,
           o_Number_Items_Found     := #t_Not_Used_Int);

// Detection the last info 1 present in the PLT, means last baggage is in handover to downstream
      L     #t_TRS3_Info; 
      L     1; 
      ==I   ; 
      FN    #s_FN_TRS3_Info_1; 
      JCN   HA01; 

      CALL "FC_PLT_Write" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[3].DB_PLT_Number,
           i_Position               := #s_Run_Out_Distanc_E_Save,
           i_Info_State             := W#16#0,
           i_Info_Physical          := -3,
           i_LNK                    := 0,
           i_DB_Event_Num           := #t_DB_Event_Num);

HA01: NOP   0; 
//- searching-up from the begining of the section until Runout distance, if a leading edge is found then Activate the Section
      CALL "FC_PLT_Srch_Inf_Up" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[3].DB_PLT_Number,
           i_Position               := #s_DB_PLT_Info[3].Conveyor_Length,
           i_Window                 := #i_CFG_Gap,
           i_Info                   := 1,
           o_Position               := #t_Not_Used_Int,
           o_Info                   := #t_TRS3_Info,
           o_LNK                    := #t_Not_Used_Int,
           o_DB_PLT_Num             := #t_Not_Used_Int,
           o_Number_Items_Found     := #t_Not_Used_Int);

      CALL "FC_PLT_Srch_Inf_Dwn" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[3].DB_PLT_Number,
           i_Position               := #s_DB_PLT_Info[3].Conveyor_Length,
           i_Window                 := #s_DB_PLT_Info[3].Conveyor_Length,
           i_Info                   := -3,
           o_Position               := #t_Not_Used_Int,
           o_Info                   := #t_TRS3_Inf_E_S,
           o_LNK                    := #t_Not_Used_Int,
           o_DB_PLT_Num             := #t_Not_Used_Int,
           o_Number_Items_Found     := #t_Not_Used_Int);

// Activation of the TRS3
      A(    ; // IF leading edge(1) is found on the search window
      L     #t_TRS3_Info; 
      L     1; 
      ==I   ; 
      )     ; 
      O(    ; 
      L     #s_Item_Info[3].Number_Items_Found; // OR Section not empty
      L     0; 
      >I    ; 
      )     ; 
      O(    ; 
      L     #t_TRS3_Inf_E_S; 
      L     -3; 
      ==I   ; 
      )     ; 
      =     #s_TRS3_Activate; //THEN Activate the Section

//Check Die-Back during Flush, If downstream not running stop request
      AN    #s_DB_PLT_Info[4].Conveyor_Run; 
      A(    ; 
      L     #s_Item_Info[4].Number_Items_Found; 
      L     0; 
      >I    ; 
      )     ; 
      A     #s_Start_Flush_Memory; 
      R     #s_TRS3_Activate; 

//---Handling the Request Run 
      A     #s_Request_Run; 
      A     #s_TRS3_Activate; 
      =     #o_TRS3_CMD_Req_Run; 
      JCN   HA99; 

//--------------Cascade delay---------------//
      A     #s_TRS4_Activate; 
      AN    #o_TRS4_CMD_Req_Run; 
      JCN   HA02; 

      L     #i_CFG_Cascade_Delay_Time; // Load the start-up delay
      T     #s_TRS3_Start_Delay_Time; // transfer to the memory


HA02: L     #s_TRS3_Start_Delay_Time; // Then count down the start-up delay
      L     "MW_Prev_Cycle_Time"; 
      -I    ; 
      JPZ   HA03; // If below zero, then set back at zero
      L     0; 
HA03: T     #s_TRS3_Start_Delay_Time; 

      L     #s_TRS3_Start_Delay_Time; // If the delay time is zero
      L     0; 
      <=I   ; 
      JCN   HA04; //If it more than zero than jump to the label

      SET   ; // Then cascade delay is done ready to run the motor
      =     #s_TRS3_Start_Delay_Ok; 
      JU    HA05; 

HA04: CLR   ; 
      =     #s_TRS3_Start_Delay_Ok; // Motor is not ready to run  


HA05: A     #s_Request_Run; // Request Run
      A     #s_TRS3_Start_Delay_Ok; // Cascade delay ok
      =     #o_TRS3_CMD_Req_Run; // Then Run the TRS2 

HA99: NOP   0; 
NETWORK
TITLE =IA: Handling TRS4
//If there is bag available on TRS3 run out distance then activate the 
//TRS4.
//TRS4 will run without cascade delay, if TRS5 is not activated.
//If Request run is active and section 4 is activated then command to Run section
//-4
      L     #s_DB_PLT_Info[4].DB_PLT_Number; // If section PLT-DB is zero jump to end of the network
      L     1; 
      >I    ; 
      JCN   IA99; 

//When Flush action is initiate conveyor runs one conveyor length
      A     #t_OS_Flush_Memory; 
      JCN   IA10; 

      CALL "FC_PLT_Write" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[4].DB_PLT_Number,
           i_Position               := #s_DB_PLT_Info[4].Conveyor_Length,
           i_Info_State             := W#16#0,
           i_Info_Physical          := -3,
           i_LNK                    := 0,
           i_DB_Event_Num           := #t_DB_Event_Num);

IA10: NOP   0; 

// Run out energy saving (conveyor not active) during flush 
      CALL "FC_PLT_Srch_Inf_Dwn" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[4].DB_PLT_Number,
           i_Position               := #s_DB_PLT_Info[4].Conveyor_Length,
           i_Window                 := #s_DB_PLT_Info[4].Conveyor_Length,
           i_Info                   := 1,
           o_Position               := #t_Not_Used_Int,
           o_Info                   := #t_TRS4_Info,
           o_LNK                    := #t_Not_Used_Int,
           o_DB_PLT_Num             := #t_Not_Used_Int,
           o_Number_Items_Found     := #t_Not_Used_Int);

// Detection the last info 1 present in the PLT, means last baggage is in handover to downstream
      L     #t_TRS4_Info; 
      L     1; 
      ==I   ; 
      FN    #s_FN_TRS4_Info_1; 
      JCN   IA01; 

      CALL "FC_PLT_Write" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[4].DB_PLT_Number,
           i_Position               := #s_Run_Out_Distanc_E_Save,
           i_Info_State             := W#16#0,
           i_Info_Physical          := -3,
           i_LNK                    := 0,
           i_DB_Event_Num           := #t_DB_Event_Num);

IA01: NOP   0; 
//- searching-up from the begining of the section until Runout distance, if a leading edge is found then Activate the Section
      CALL "FC_PLT_Srch_Inf_Up" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[4].DB_PLT_Number,
           i_Position               := #s_DB_PLT_Info[4].Conveyor_Length,
           i_Window                 := #i_CFG_Run_Out_Distance,
           i_Info                   := 1,
           o_Position               := #t_Not_Used_Int,
           o_Info                   := #t_TRS4_Info,
           o_LNK                    := #t_Not_Used_Int,
           o_DB_PLT_Num             := #t_Not_Used_Int,
           o_Number_Items_Found     := #t_Not_Used_Int);

      CALL "FC_PLT_Srch_Inf_Dwn" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[4].DB_PLT_Number,
           i_Position               := #s_DB_PLT_Info[4].Conveyor_Length,
           i_Window                 := #s_DB_PLT_Info[4].Conveyor_Length,
           i_Info                   := -3,
           o_Position               := #t_Not_Used_Int,
           o_Info                   := #t_TRS4_Inf_E_S,
           o_LNK                    := #t_Not_Used_Int,
           o_DB_PLT_Num             := #t_Not_Used_Int,
           o_Number_Items_Found     := #t_Not_Used_Int);

// Activation of the TRS4
      A(    ; // IF leading edge(1) is found on the search window
      L     #t_TRS4_Info; 
      L     1; 
      ==I   ; 
      )     ; 
      O(    ; 
      L     #s_Item_Info[4].Number_Items_Found; // OR Section not empty
      L     0; 
      >I    ; 
      )     ; 
      O(    ; 
      L     #t_TRS4_Inf_E_S; 
      L     -3; 
      ==I   ; 
      )     ; 
      =     #s_TRS4_Activate; //THEN Activate the Section

//Check Die-Back during Flush, If downstream not running stop request
      AN    #s_DB_PLT_Info[5].Conveyor_Run; 
      A(    ; 
      L     #s_Item_Info[5].Number_Items_Found; 
      L     0; 
      >I    ; 
      )     ; 
      A     #s_Start_Flush_Memory; 
      R     #s_TRS4_Activate; 

//---Handling the Request Run 
      A     #s_Request_Run; 
      A     #s_TRS4_Activate; 
      =     #o_TRS4_CMD_Req_Run; 
      JCN   IA99; 

//--------------Cascade delay---------------//
      A     #s_TRS5_Activate; 
      AN    #o_TRS5_CMD_Req_Run; 
      JCN   IA02; 

      L     #i_CFG_Cascade_Delay_Time; // Load the start-up delay
      T     #s_TRS4_Start_Delay_Time; // transfer to the memory


IA02: L     #s_TRS4_Start_Delay_Time; // Then count down the start-up delay
      L     "MW_Prev_Cycle_Time"; 
      -I    ; 
      JPZ   IA03; // If below zero, then set back at zero
      L     0; 
IA03: T     #s_TRS4_Start_Delay_Time; 

      L     #s_TRS4_Start_Delay_Time; // If the delay time is zero
      L     0; 
      <=I   ; 
      JCN   IA04; //If it more than zero than jump to the label

      SET   ; // Then cascade delay is done ready to run the motor
      =     #s_TRS4_Start_Delay_Ok; 
      JU    IA05; 

IA04: CLR   ; 
      =     #s_TRS4_Start_Delay_Ok; // Motor is not ready to run  

IA05: A     #s_Request_Run; // Request Run
      A     #s_TRS4_Start_Delay_Ok; // Cascade delay ok
      =     #o_TRS4_CMD_Req_Run; // Then Run the TRS4 

IA99: NOP   0; 
NETWORK
TITLE =JA: Handling TRS5
//If there is bag available on TRS4 run out distance then activate the 
//TRS5.
//TRS5 will run without cascade delay, if TRS6 is not activated.
//If Request run is active and section 5 is activated then command to Run section
//-5
      L     #s_DB_PLT_Info[5].DB_PLT_Number; // If section PLT-DB is zero jump to end of the network
      L     1; 
      >I    ; 
      JCN   JA99; 

//When Flush action is initiate conveyor runs one conveyor length
      A     #t_OS_Flush_Memory; 
      JCN   JA10; 

      CALL "FC_PLT_Write" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[5].DB_PLT_Number,
           i_Position               := #s_DB_PLT_Info[5].Conveyor_Length,
           i_Info_State             := W#16#0,
           i_Info_Physical          := -3,
           i_LNK                    := 0,
           i_DB_Event_Num           := #t_DB_Event_Num);

JA10: NOP   0; 

// Run out energy saving (conveyor not active) during flush 
      CALL "FC_PLT_Srch_Inf_Dwn" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[5].DB_PLT_Number,
           i_Position               := #s_DB_PLT_Info[5].Conveyor_Length,
           i_Window                 := #s_DB_PLT_Info[5].Conveyor_Length,
           i_Info                   := 1,
           o_Position               := #t_Not_Used_Int,
           o_Info                   := #t_TRS5_Info,
           o_LNK                    := #t_Not_Used_Int,
           o_DB_PLT_Num             := #t_Not_Used_Int,
           o_Number_Items_Found     := #t_Not_Used_Int);

// Detection the last info 1 present in the PLT, means last baggage is in handover to downstream
      L     #t_TRS5_Info; 
      L     1; 
      ==I   ; 
      FN    #s_FN_TRS5_Info_1; 
      JCN   JA01; 

      CALL "FC_PLT_Write" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[5].DB_PLT_Number,
           i_Position               := #s_Run_Out_Distanc_E_Save,
           i_Info_State             := W#16#0,
           i_Info_Physical          := -3,
           i_LNK                    := 0,
           i_DB_Event_Num           := #t_DB_Event_Num);

JA01: NOP   0; 

//- searching-up from the begining of the section until Runout distance, if a leading edge is found then Activate the Section
      CALL "FC_PLT_Srch_Inf_Up" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[5].DB_PLT_Number,
           i_Position               := #s_DB_PLT_Info[5].Conveyor_Length,
           i_Window                 := #i_CFG_Run_Out_Distance,
           i_Info                   := 1,
           o_Position               := #t_Not_Used_Int,
           o_Info                   := #t_TRS5_Info,
           o_LNK                    := #t_Not_Used_Int,
           o_DB_PLT_Num             := #t_Not_Used_Int,
           o_Number_Items_Found     := #t_Not_Used_Int);

      CALL "FC_PLT_Srch_Inf_Dwn" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[5].DB_PLT_Number,
           i_Position               := #s_DB_PLT_Info[5].Conveyor_Length,
           i_Window                 := #s_DB_PLT_Info[5].Conveyor_Length,
           i_Info                   := -3,
           o_Position               := #t_Not_Used_Int,
           o_Info                   := #t_TRS5_Inf_E_S,
           o_LNK                    := #t_Not_Used_Int,
           o_DB_PLT_Num             := #t_Not_Used_Int,
           o_Number_Items_Found     := #t_Not_Used_Int);

// Activation of the TRS5
      A(    ; // IF leading edge(1) is found on the search window
      L     #t_TRS5_Info; 
      L     1; 
      ==I   ; 
      )     ; 
      O(    ; 
      L     #s_Item_Info[5].Number_Items_Found; // OR Section not empty
      L     0; 
      >I    ; 
      )     ; 
      O(    ; 
      L     #t_TRS5_Inf_E_S; 
      L     -3; 
      ==I   ; 
      )     ; 
      =     #s_TRS5_Activate; //THEN Activate the Section

//Check Die-Back during Flush, If downstream not running stop request
      AN    #s_DB_PLT_Info[6].Conveyor_Run; 
      A(    ; 
      L     #s_Item_Info[6].Number_Items_Found; 
      L     0; 
      >I    ; 
      )     ; 
      A     #s_Start_Flush_Memory; 
      R     #s_TRS5_Activate; 

//---Handling the Request Run 
      A     #s_Request_Run; 
      A     #s_TRS5_Activate; 
      =     #o_TRS5_CMD_Req_Run; 
      JCN   JA99; 

//--------------Cascade delay---------------//
      A     #s_TRS6_Activate; 
      AN    #o_TRS6_CMD_Req_Run; 
      JCN   JA02; 

      L     #i_CFG_Cascade_Delay_Time; // Load the start-up delay
      T     #s_TRS5_Start_Delay_Time; // transfer to the memory


JA02: L     #s_TRS5_Start_Delay_Time; // Then count down the start-up delay
      L     "MW_Prev_Cycle_Time"; 
      -I    ; 
      JPZ   JA03; // If below zero, then set back at zero
      L     0; 
JA03: T     #s_TRS5_Start_Delay_Time; 

      L     #s_TRS5_Start_Delay_Time; // If the delay time is zero
      L     0; 
      <=I   ; 
      JCN   JA04; //If it more than zero than jump to the label

      SET   ; // Then cascade delay is done ready to run the motor
      =     #s_TRS5_Start_Delay_Ok; 
      JU    JA05; 

JA04: CLR   ; 
      =     #s_TRS5_Start_Delay_Ok; // Motor is not ready to run  

JA05: A     #s_Request_Run; // Request Run
      A     #s_TRS5_Start_Delay_Ok; // Cascade delay ok
      =     #o_TRS5_CMD_Req_Run; // Then Run the TRS5 

JA99: NOP   0; 
NETWORK
TITLE =KA: Handling TRS6
//If there is bag available on TRS5 run out distance then activate the 
//TRS6.
//TRS6 will run without cascade delay, if TRS1 is not activated.
//If Request run is active and section 6 is activated then command to Run section
//-6
      L     #s_DB_PLT_Info[6].DB_PLT_Number; // If section PLT-DB is zero jump to end of the network
      L     1; 
      >I    ; 
      JCN   KA99; 

//When Flush action is initiate conveyor runs one conveyor length
      A     #t_OS_Flush_Memory; 
      JCN   KA10; 

      CALL "FC_PLT_Write" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[6].DB_PLT_Number,
           i_Position               := #s_DB_PLT_Info[6].Conveyor_Length,
           i_Info_State             := W#16#0,
           i_Info_Physical          := -3,
           i_LNK                    := 0,
           i_DB_Event_Num           := #t_DB_Event_Num);

KA10: NOP   0; 

// Run out energy saving (conveyor not active) during flush 
      CALL "FC_PLT_Srch_Inf_Dwn" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[6].DB_PLT_Number,
           i_Position               := #s_DB_PLT_Info[6].Conveyor_Length,
           i_Window                 := #s_DB_PLT_Info[6].Conveyor_Length,
           i_Info                   := 1,
           o_Position               := #t_Not_Used_Int,
           o_Info                   := #t_TRS6_Info,
           o_LNK                    := #t_Not_Used_Int,
           o_DB_PLT_Num             := #t_Not_Used_Int,
           o_Number_Items_Found     := #t_Not_Used_Int);

// Detection the last info 1 present in the PLT, means last baggage is in handover to downstream
      L     #t_TRS6_Info; 
      L     1; 
      ==I   ; 
      FN    #s_FN_TRS6_Info_1; 
      JCN   KA01; 

      CALL "FC_PLT_Write" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[6].DB_PLT_Number,
           i_Position               := #s_Run_Out_Distanc_E_Save,
           i_Info_State             := W#16#0,
           i_Info_Physical          := -3,
           i_LNK                    := 0,
           i_DB_Event_Num           := #t_DB_Event_Num);

KA01: NOP   0; 

//- searching-up from the begining of the section until Runout distance, if a leading edge is found then Activate the Section
      CALL "FC_PLT_Srch_Inf_Up" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[6].DB_PLT_Number,
           i_Position               := #s_DB_PLT_Info[6].Conveyor_Length,
           i_Window                 := #i_CFG_Run_Out_Distance,
           i_Info                   := 1,
           o_Position               := #t_Not_Used_Int,
           o_Info                   := #t_TRS6_Info,
           o_LNK                    := #t_Not_Used_Int,
           o_DB_PLT_Num             := #t_Not_Used_Int,
           o_Number_Items_Found     := #t_Not_Used_Int);

      CALL "FC_PLT_Srch_Inf_Dwn" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[6].DB_PLT_Number,
           i_Position               := #s_DB_PLT_Info[6].Conveyor_Length,
           i_Window                 := #s_DB_PLT_Info[6].Conveyor_Length,
           i_Info                   := -3,
           o_Position               := #t_Not_Used_Int,
           o_Info                   := #t_TRS6_Inf_E_S,
           o_LNK                    := #t_Not_Used_Int,
           o_DB_PLT_Num             := #t_Not_Used_Int,
           o_Number_Items_Found     := #t_Not_Used_Int);

// Activation of the TRS6
      A(    ; // IF leading edge(1) is found on the search window
      L     #t_TRS6_Info; 
      L     1; 
      ==I   ; 
      )     ; 
      O(    ; 
      L     #s_Item_Info[6].Number_Items_Found; // OR Section not empty
      L     0; 
      >I    ; 
      )     ; 
      O(    ; 
      L     #t_TRS6_Inf_E_S; 
      L     -3; 
      ==I   ; 
      )     ; 
      =     #s_TRS6_Activate; //THEN Activate the Section

//Check Die-Back during Flush, If downstream not running stop request
      AN    #s_DB_PLT_Info[7].Conveyor_Run; 
      A(    ; 
      L     #s_Item_Info[7].Number_Items_Found; 
      L     0; 
      >I    ; 
      )     ; 
      A     #s_Start_Flush_Memory; 
      R     #s_TRS6_Activate; 

//---Handling the Request Run 
      A     #s_Request_Run; 
      A     #s_TRS6_Activate; 
      =     #o_TRS6_CMD_Req_Run; 
      JCN   KA99; 

//--------------Cascade delay---------------//
      A     #s_TRS7_Activate; 
      AN    #o_TRS7_CMD_Req_Run; 
      JCN   KA02; 
      L     #i_CFG_Cascade_Delay_Time; // Load the start-up delay
      T     #s_TRS6_Start_Delay_Time; // transfer to the memory


KA02: L     #s_TRS6_Start_Delay_Time; // Then count down the start-up delay
      L     "MW_Prev_Cycle_Time"; 
      -I    ; 
      JPZ   KA03; // If below zero, then set back at zero
      L     0; 
KA03: T     #s_TRS6_Start_Delay_Time; 

      L     #s_TRS6_Start_Delay_Time; // If the delay time is zero
      L     0; 
      <=I   ; 
      JCN   KA04; //If it more than zero than jump to the label

      SET   ; // Then cascade delay is done ready to run the motor
      =     #s_TRS6_Start_Delay_Ok; 
      JU    KA05; 

KA04: CLR   ; 
      =     #s_TRS6_Start_Delay_Ok; // Motor is not ready to run  

KA05: A     #s_Request_Run; // Request Run
      A     #s_TRS6_Start_Delay_Ok; // Cascade delay ok
      =     #o_TRS6_CMD_Req_Run; // Then Run the TRS6 

KA99: NOP   0; 
NETWORK
TITLE =LA: Handling TRS7
//If there is bag available on TRS6 run out distance then activate the 
//TRS1.
//TRS1 will run without cascade delay, if TRS8 is not activated.
//If Request run is active and section 7 is activated then command to Run section
//-7
      L     #s_DB_PLT_Info[7].DB_PLT_Number; // If section PLT-DB is zero jump to end of the network
      L     1; 
      >I    ; 
      JCN   LA99; 

//When Flush action is initiate conveyor runs one conveyor length
      A     #t_OS_Flush_Memory; 
      JCN   LA10; 

      CALL "FC_PLT_Write" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[7].DB_PLT_Number,
           i_Position               := #s_DB_PLT_Info[7].Conveyor_Length,
           i_Info_State             := W#16#0,
           i_Info_Physical          := -3,
           i_LNK                    := 0,
           i_DB_Event_Num           := #t_DB_Event_Num);

LA10: NOP   0; 

// Run out energy saving (conveyor not active) during flush 
      CALL "FC_PLT_Srch_Inf_Dwn" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[7].DB_PLT_Number,
           i_Position               := #s_DB_PLT_Info[7].Conveyor_Length,
           i_Window                 := #s_DB_PLT_Info[7].Conveyor_Length,
           i_Info                   := 1,
           o_Position               := #t_Not_Used_Int,
           o_Info                   := #t_TRS7_Info,
           o_LNK                    := #t_Not_Used_Int,
           o_DB_PLT_Num             := #t_Not_Used_Int,
           o_Number_Items_Found     := #t_Not_Used_Int);

// Detection the last info 1 present in the PLT, means last baggage is in handover to downstream
      L     #t_TRS7_Info; 
      L     1; 
      ==I   ; 
      FN    #s_FN_TRS7_Info_1; 
      JCN   LA01; 

      CALL "FC_PLT_Write" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[7].DB_PLT_Number,
           i_Position               := #s_Run_Out_Distanc_E_Save,
           i_Info_State             := W#16#0,
           i_Info_Physical          := -3,
           i_LNK                    := 0,
           i_DB_Event_Num           := #t_DB_Event_Num);

LA01: NOP   0; 

//- searching-up from the begining of the section until Runout distance, if a leading edge is found then Activate the Section
      CALL "FC_PLT_Srch_Inf_Up" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[7].DB_PLT_Number,
           i_Position               := #s_DB_PLT_Info[7].Conveyor_Length,
           i_Window                 := #i_CFG_Run_Out_Distance,
           i_Info                   := 1,
           o_Position               := #t_Not_Used_Int,
           o_Info                   := #t_TRS7_Info,
           o_LNK                    := #t_Not_Used_Int,
           o_DB_PLT_Num             := #t_Not_Used_Int,
           o_Number_Items_Found     := #t_Not_Used_Int);

      CALL "FC_PLT_Srch_Inf_Dwn" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[7].DB_PLT_Number,
           i_Position               := #s_DB_PLT_Info[7].Conveyor_Length,
           i_Window                 := #s_DB_PLT_Info[7].Conveyor_Length,
           i_Info                   := -3,
           o_Position               := #t_Not_Used_Int,
           o_Info                   := #t_TRS7_Inf_E_S,
           o_LNK                    := #t_Not_Used_Int,
           o_DB_PLT_Num             := #t_Not_Used_Int,
           o_Number_Items_Found     := #t_Not_Used_Int);

// Activation of the TRS1
      A(    ; // IF leading edge(1) is found on the search window
      L     #t_TRS7_Info; 
      L     1; 
      ==I   ; 
      )     ; 
      O(    ; 
      L     #s_Item_Info[7].Number_Items_Found; // OR Section not empty
      L     0; 
      >I    ; 
      )     ; 
      O(    ; 
      L     #t_TRS7_Inf_E_S; 
      L     -3; 
      ==I   ; 
      )     ; 
      =     #s_TRS7_Activate; //THEN Activate the Section

//Check Die-Back during Flush, If downstream not running stop request
      AN    #s_DB_PLT_Info[8].Conveyor_Run; 
      A(    ; 
      L     #s_Item_Info[8].Number_Items_Found; 
      L     0; 
      >I    ; 
      )     ; 
      A     #s_Start_Flush_Memory; 
      R     #s_TRS7_Activate; 

//---Handling the Request Run 
      A     #s_Request_Run; 
      A     #s_TRS7_Activate; 
      =     #o_TRS7_CMD_Req_Run; 
      JCN   LA99; 

//--------------Cascade delay---------------//
      A     #s_TRS8_Activate; 
      AN    #o_TRS8_CMD_Req_Run; 
      JCN   LA02; 

      L     #i_CFG_Cascade_Delay_Time; // Load the start-up delay
      T     #s_TRS7_Start_Delay_Time; // transfer to the memory


LA02: L     #s_TRS7_Start_Delay_Time; // Then count down the start-up delay
      L     "MW_Prev_Cycle_Time"; 
      -I    ; 
      JPZ   LA03; // If below zero, then set back at zero
      L     0; 
LA03: T     #s_TRS7_Start_Delay_Time; 

      L     #s_TRS7_Start_Delay_Time; // If the delay time is zero
      L     0; 
      <=I   ; 
      JCN   LA04; //If it more than zero than jump to the label

      SET   ; // Then cascade delay is done ready to run the motor
      =     #s_TRS7_Start_Delay_Ok; 
      JU    LA05; 

LA04: CLR   ; 
      =     #s_TRS7_Start_Delay_Ok; // Motor is not ready to run  

LA05: A     #s_Request_Run; // Request Run
      A     #s_TRS7_Start_Delay_Ok; // Cascade delay ok
      =     #o_TRS7_CMD_Req_Run; // Then Run the TRS7 

LA99: NOP   0; 
NETWORK
TITLE =MA: Handling TRS8
//If there is bag available on TRS1 run out distance then activate the
//TRS8.
//If Request run is active and section 8 is activated then command to Run section
//-8
      L     #s_DB_PLT_Info[8].DB_PLT_Number; // If section PLT-DB is zero jump to end of the network
      L     1; 
      >I    ; 
      JCN   MA99; 

//When Flush action is initiate conveyor runs one conveyor length
      A     #t_OS_Flush_Memory; 
      JCN   MA10; 

      CALL "FC_PLT_Write" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[8].DB_PLT_Number,
           i_Position               := #s_DB_PLT_Info[8].Conveyor_Length,
           i_Info_State             := W#16#0,
           i_Info_Physical          := -3,
           i_LNK                    := 0,
           i_DB_Event_Num           := #t_DB_Event_Num);

MA10: NOP   0; 

// Run out energy saving (conveyor not active) during flush 
      CALL "FC_PLT_Srch_Inf_Dwn" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[8].DB_PLT_Number,
           i_Position               := #s_DB_PLT_Info[8].Conveyor_Length,
           i_Window                 := #s_DB_PLT_Info[8].Conveyor_Length,
           i_Info                   := 1,
           o_Position               := #t_Not_Used_Int,
           o_Info                   := #t_TRS8_Info,
           o_LNK                    := #t_Not_Used_Int,
           o_DB_PLT_Num             := #t_Not_Used_Int,
           o_Number_Items_Found     := #t_Not_Used_Int);

// Detection the last info 1 present in the PLT, means last baggage is in handover to downstream
      L     #t_TRS8_Info; 
      L     1; 
      ==I   ; 
      FN    #s_FN_TRS8_Info_1; 
      JCN   MA01; 

      CALL "FC_PLT_Write" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[8].DB_PLT_Number,
           i_Position               := #s_Run_Out_Distanc_E_Save,
           i_Info_State             := W#16#0,
           i_Info_Physical          := -3,
           i_LNK                    := 0,
           i_DB_Event_Num           := #t_DB_Event_Num);

MA01: NOP   0; 

//- searching-up from the begining of the section until Runout distance, if a leading edge is found then Activate the Section
      CALL "FC_PLT_Srch_Inf_Up" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[8].DB_PLT_Number,
           i_Position               := #s_DB_PLT_Info[8].Conveyor_Length,
           i_Window                 := #i_CFG_Run_Out_Distance,
           i_Info                   := 1,
           o_Position               := #t_Not_Used_Int,
           o_Info                   := #t_TRS8_Info,
           o_LNK                    := #t_Not_Used_Int,
           o_DB_PLT_Num             := #t_Not_Used_Int,
           o_Number_Items_Found     := #t_Not_Used_Int);

      CALL "FC_PLT_Srch_Inf_Dwn" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[8].DB_PLT_Number,
           i_Position               := #s_DB_PLT_Info[8].Conveyor_Length,
           i_Window                 := #s_DB_PLT_Info[8].Conveyor_Length,
           i_Info                   := -3,
           o_Position               := #t_Not_Used_Int,
           o_Info                   := #t_TRS8_Inf_E_S,
           o_LNK                    := #t_Not_Used_Int,
           o_DB_PLT_Num             := #t_Not_Used_Int,
           o_Number_Items_Found     := #t_Not_Used_Int);

// Activation of the TRS8
      A(    ; // IF leading edge(1) is found on the search window
      L     #t_TRS8_Info; 
      L     1; 
      ==I   ; 
      )     ; 
      O(    ; 
      L     #s_Item_Info[8].Number_Items_Found; // OR Section not empty
      L     0; 
      >I    ; 
      )     ; 
      O(    ; 
      L     #t_TRS8_Inf_E_S; 
      L     -3; 
      ==I   ; 
      )     ; 
      =     #s_TRS8_Activate; //THEN Activate the Section

//---If Motor is not activated then jump to the end of the network
      A     #s_TRS8_Activate; 
      A     #s_Request_Run; //Request Run
      =     #o_TRS8_CMD_Req_Run; //Run the TRS8

MA99: NOP   0; 
NETWORK
TITLE =NA:Search functions

      NOP   0; 
// Search number of bag present Section 1
      L     #s_DB_PLT_Info[1].DB_PLT_Number; // IF PLT is existing
      L     1; 
      >I    ; 
      JCN   NA01; // THEN search

      CALL "FC_PLT_Srch_Inf_Up" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[1].DB_PLT_Number,
           i_Position               := 0,
           i_Window                 := #s_DB_PLT_Info[1].Conveyor_Length,
           i_Info                   := 1,
           o_Position               := #s_Item_Info[1].Position,
           o_Info                   := #s_Item_Info[1].Info,
           o_LNK                    := #s_Item_Info[1].Data,
           o_DB_PLT_Num             := #s_Item_Info[1].DB_PLT,
           o_Number_Items_Found     := #s_Item_Info[1].Number_Items_Found);

      CALL "FC_PLT_Srch_Inf_Up" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[1].DB_PLT_Number,
           i_Position               := 0,
           i_Window                 := #s_DB_PLT_Info[1].Conveyor_Length,
           i_Info                   := 2,
           o_Position               := #t_Not_Used_Int,
           o_Info                   := #t_Not_Used_Int,
           o_LNK                    := #t_Not_Used_Int,
           o_DB_PLT_Num             := #t_Not_Used_Int,
           o_Number_Items_Found     := #t_TRS1_Items_Present);

      L     #s_Item_Info[1].Number_Items_Found; //   If there are no leading items
      L     0; 
      <=I   ; 
      JCN   NA11; 

      L     #t_TRS1_Items_Present; // But there are trailing items
      L     0; 
      >I    ; 
      JCN   NA11; 

      L     1; // Then there are items present!
      T     #s_Item_Info[1].Number_Items_Found; 

NA11: NOP   0; 

// Search number of bag present Section 2
NA01: L     #s_DB_PLT_Info[2].DB_PLT_Number; // IF PLT is existing
      L     1; 
      >I    ; 
      JCN   NA02; // THEN search

      CALL "FC_PLT_Srch_Inf_Up" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[2].DB_PLT_Number,
           i_Position               := 0,
           i_Window                 := #s_DB_PLT_Info[2].Conveyor_Length,
           i_Info                   := 1,
           o_Position               := #s_Item_Info[2].Position,
           o_Info                   := #s_Item_Info[2].Info,
           o_LNK                    := #s_Item_Info[2].Data,
           o_DB_PLT_Num             := #s_Item_Info[2].DB_PLT,
           o_Number_Items_Found     := #s_Item_Info[2].Number_Items_Found);

      CALL "FC_PLT_Srch_Inf_Up" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[2].DB_PLT_Number,
           i_Position               := 0,
           i_Window                 := #s_DB_PLT_Info[2].Conveyor_Length,
           i_Info                   := 2,
           o_Position               := #t_Not_Used_Int,
           o_Info                   := #t_Not_Used_Int,
           o_LNK                    := #t_Not_Used_Int,
           o_DB_PLT_Num             := #t_Not_Used_Int,
           o_Number_Items_Found     := #t_TRS2_Items_Present);

      L     #s_Item_Info[2].Number_Items_Found; //   If there are no leading items
      L     0; 
      <=I   ; 
      JCN   NA12; 

      L     #t_TRS2_Items_Present; // But there are trailing items
      L     0; 
      >I    ; 
      JCN   NA12; 

      L     1; // Then there are items present!
      T     #s_Item_Info[2].Number_Items_Found; 

NA12: NOP   0; 

// Search number of bag present Section 3
NA02: L     #s_DB_PLT_Info[3].DB_PLT_Number; // IF PLT is existing
      L     1; 
      >I    ; 
      JCN   NA03; // THEN search

      CALL "FC_PLT_Srch_Inf_Up" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[3].DB_PLT_Number,
           i_Position               := 0,
           i_Window                 := #s_DB_PLT_Info[3].Conveyor_Length,
           i_Info                   := 1,
           o_Position               := #s_Item_Info[3].Position,
           o_Info                   := #s_Item_Info[3].Info,
           o_LNK                    := #s_Item_Info[3].Data,
           o_DB_PLT_Num             := #s_Item_Info[3].DB_PLT,
           o_Number_Items_Found     := #s_Item_Info[3].Number_Items_Found);

      CALL "FC_PLT_Srch_Inf_Up" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[3].DB_PLT_Number,
           i_Position               := 0,
           i_Window                 := #s_DB_PLT_Info[3].Conveyor_Length,
           i_Info                   := 2,
           o_Position               := #t_Not_Used_Int,
           o_Info                   := #t_Not_Used_Int,
           o_LNK                    := #t_Not_Used_Int,
           o_DB_PLT_Num             := #t_Not_Used_Int,
           o_Number_Items_Found     := #t_TRS3_Items_Present);

      L     #s_Item_Info[3].Number_Items_Found; //   If there are no leading items
      L     0; 
      <=I   ; 
      JCN   NA13; 

      L     #t_TRS3_Items_Present; // But there are trailing items
      L     0; 
      >I    ; 
      JCN   NA13; 

      L     1; // Then there are items present!
      T     #s_Item_Info[3].Number_Items_Found; 

NA13: NOP   0; 

// Search number of bag present Section 4
NA03: L     #s_DB_PLT_Info[4].DB_PLT_Number; // IF PLT is existing
      L     1; 
      >I    ; 
      JCN   NA04; // THEN search

      CALL "FC_PLT_Srch_Inf_Up" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[4].DB_PLT_Number,
           i_Position               := 0,
           i_Window                 := #s_DB_PLT_Info[4].Conveyor_Length,
           i_Info                   := 1,
           o_Position               := #s_Item_Info[4].Position,
           o_Info                   := #s_Item_Info[4].Info,
           o_LNK                    := #s_Item_Info[4].Data,
           o_DB_PLT_Num             := #s_Item_Info[4].DB_PLT,
           o_Number_Items_Found     := #s_Item_Info[4].Number_Items_Found);

      CALL "FC_PLT_Srch_Inf_Up" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[4].DB_PLT_Number,
           i_Position               := 0,
           i_Window                 := #s_DB_PLT_Info[4].Conveyor_Length,
           i_Info                   := 2,
           o_Position               := #t_Not_Used_Int,
           o_Info                   := #t_Not_Used_Int,
           o_LNK                    := #t_Not_Used_Int,
           o_DB_PLT_Num             := #t_Not_Used_Int,
           o_Number_Items_Found     := #t_TRS4_Items_Present);

      L     #s_Item_Info[4].Number_Items_Found; //   If there are no leading items
      L     0; 
      <=I   ; 
      JCN   NA14; 

      L     #t_TRS4_Items_Present; // But there are trailing items
      L     0; 
      >I    ; 
      JCN   NA14; 

      L     1; // Then there are items present!
      T     #s_Item_Info[4].Number_Items_Found; 

NA14: NOP   0; 


// Search number of bag present Section 5
NA04: L     #s_DB_PLT_Info[5].DB_PLT_Number; // IF PLT is existing
      L     1; 
      >I    ; 
      JCN   NA05; // THEN search

      CALL "FC_PLT_Srch_Inf_Up" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[5].DB_PLT_Number,
           i_Position               := 0,
           i_Window                 := #s_DB_PLT_Info[5].Conveyor_Length,
           i_Info                   := 1,
           o_Position               := #s_Item_Info[5].Position,
           o_Info                   := #s_Item_Info[5].Info,
           o_LNK                    := #s_Item_Info[5].Data,
           o_DB_PLT_Num             := #s_Item_Info[5].DB_PLT,
           o_Number_Items_Found     := #s_Item_Info[5].Number_Items_Found);

      CALL "FC_PLT_Srch_Inf_Up" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[5].DB_PLT_Number,
           i_Position               := 0,
           i_Window                 := #s_DB_PLT_Info[5].Conveyor_Length,
           i_Info                   := 2,
           o_Position               := #t_Not_Used_Int,
           o_Info                   := #t_Not_Used_Int,
           o_LNK                    := #t_Not_Used_Int,
           o_DB_PLT_Num             := #t_Not_Used_Int,
           o_Number_Items_Found     := #t_TRS5_Items_Present);

      L     #s_Item_Info[5].Number_Items_Found; //   If there are no leading items
      L     0; 
      <=I   ; 
      JCN   NA15; 

      L     #t_TRS5_Items_Present; // But there are trailing items
      L     0; 
      >I    ; 
      JCN   NA15; 

      L     1; // Then there are items present!
      T     #s_Item_Info[5].Number_Items_Found; 

NA15: NOP   0; 

// Search number of bag present Section 6
NA05: L     #s_DB_PLT_Info[6].DB_PLT_Number; // IF PLT is existing
      L     1; 
      >I    ; 
      JCN   NA06; // THEN search

      CALL "FC_PLT_Srch_Inf_Up" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[6].DB_PLT_Number,
           i_Position               := 0,
           i_Window                 := #s_DB_PLT_Info[6].Conveyor_Length,
           i_Info                   := 1,
           o_Position               := #s_Item_Info[6].Position,
           o_Info                   := #s_Item_Info[6].Info,
           o_LNK                    := #s_Item_Info[6].Data,
           o_DB_PLT_Num             := #s_Item_Info[6].DB_PLT,
           o_Number_Items_Found     := #s_Item_Info[6].Number_Items_Found);

      CALL "FC_PLT_Srch_Inf_Up" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[6].DB_PLT_Number,
           i_Position               := 0,
           i_Window                 := #s_DB_PLT_Info[6].Conveyor_Length,
           i_Info                   := 2,
           o_Position               := #t_Not_Used_Int,
           o_Info                   := #t_Not_Used_Int,
           o_LNK                    := #t_Not_Used_Int,
           o_DB_PLT_Num             := #t_Not_Used_Int,
           o_Number_Items_Found     := #t_TRS6_Items_Present);

      L     #s_Item_Info[6].Number_Items_Found; //   If there are no leading items
      L     0; 
      <=I   ; 
      JCN   NA16; 

      L     #t_TRS6_Items_Present; // But there are trailing items
      L     0; 
      >I    ; 
      JCN   NA16; 

      L     1; // Then there are items present!
      T     #s_Item_Info[6].Number_Items_Found; 

NA16: NOP   0; 

// Search number of bag present Section 7
NA06: L     #s_DB_PLT_Info[7].DB_PLT_Number; 
      L     1; 
      >I    ; 
      JCN   NA07; 

      CALL "FC_PLT_Srch_Inf_Up" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[7].DB_PLT_Number,
           i_Position               := 0,
           i_Window                 := #s_DB_PLT_Info[7].Conveyor_Length,
           i_Info                   := 1,
           o_Position               := #s_Item_Info[7].Position,
           o_Info                   := #s_Item_Info[7].Info,
           o_LNK                    := #s_Item_Info[7].Data,
           o_DB_PLT_Num             := #s_Item_Info[7].DB_PLT,
           o_Number_Items_Found     := #s_Item_Info[7].Number_Items_Found);

      CALL "FC_PLT_Srch_Inf_Up" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[7].DB_PLT_Number,
           i_Position               := 0,
           i_Window                 := #s_DB_PLT_Info[7].Conveyor_Length,
           i_Info                   := 2,
           o_Position               := #t_Not_Used_Int,
           o_Info                   := #t_Not_Used_Int,
           o_LNK                    := #t_Not_Used_Int,
           o_DB_PLT_Num             := #t_Not_Used_Int,
           o_Number_Items_Found     := #t_TRS7_Items_Present);

      L     #s_Item_Info[7].Number_Items_Found; //   If there are no leading items
      L     0; 
      <=I   ; 
      JCN   NA17; 

      L     #t_TRS7_Items_Present; // But there are trailing items
      L     0; 
      >I    ; 
      JCN   NA17; 

      L     1; // Then there are items present!
      T     #s_Item_Info[7].Number_Items_Found; 

NA17: NOP   0; 

NA07: L     #s_DB_PLT_Info[8].DB_PLT_Number; // IF PLT is existing
      L     1; 
      >I    ; 
      JCN   NA99; // THEN search

      CALL "FC_PLT_Srch_Inf_Up" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[8].DB_PLT_Number,
           i_Position               := 0,
           i_Window                 := #s_DB_PLT_Info[8].Conveyor_Length,
           i_Info                   := 1,
           o_Position               := #s_Item_Info[8].Position,
           o_Info                   := #s_Item_Info[8].Info,
           o_LNK                    := #s_Item_Info[8].Data,
           o_DB_PLT_Num             := #s_Item_Info[8].DB_PLT,
           o_Number_Items_Found     := #s_Item_Info[8].Number_Items_Found);

      CALL "FC_PLT_Srch_Inf_Up" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[8].DB_PLT_Number,
           i_Position               := 0,
           i_Window                 := #s_DB_PLT_Info[8].Conveyor_Length,
           i_Info                   := 2,
           o_Position               := #t_Not_Used_Int,
           o_Info                   := #t_Not_Used_Int,
           o_LNK                    := #t_Not_Used_Int,
           o_DB_PLT_Num             := #t_Not_Used_Int,
           o_Number_Items_Found     := #t_TRS8_Items_Present);

      L     #s_Item_Info[8].Number_Items_Found; //   If there are no leading items
      L     0; 
      <=I   ; 
      JCN   NA99; 

      L     #t_TRS8_Items_Present; // But there are trailing items
      L     0; 
      >I    ; 
      JCN   NA99; 

      L     1; // Then there are items present!
      T     #s_Item_Info[8].Number_Items_Found; 

NA99: NOP   0; 
NETWORK
TITLE =OA: Determination of the absolute position of the first item
//The most item downstream (in the flow) founded is considered as first item 
//- Section 1 is the most upstream
//- Section 8 is the most downstream
//Considering the position where the first iten is founded, the lenth of the 
//downstream conveyor(s) is added to the relative position of the item on is own 
//conveyor to obtain the absolute posiion of the item in the LSZ
//
// Section 8 (most downstream)
      L     #s_Item_Info[8].Number_Items_Found; 
      L     0; 
      >I    ; 
      JCN   OA01; 

      L     #s_Item_Info[8].Position; 
      T     #s_Abs_Pos_First_Item; 
      JU    OA99; 

// Section 7
OA01: L     #s_Item_Info[7].Number_Items_Found; 
      L     0; 
      >I    ; 
      JCN   OA02; 

      L     #s_DB_PLT_Info[8].Conveyor_Length; 
      L     #s_Item_Info[7].Position; 
      +I    ; 
      T     #s_Abs_Pos_First_Item; 
      JU    OA99; 

// Section 6
OA02: L     #s_Item_Info[6].Number_Items_Found; 
      L     0; 
      >I    ; 
      JCN   OA03; 

      L     #s_DB_PLT_Info[8].Conveyor_Length; 
      L     #s_DB_PLT_Info[7].Conveyor_Length; 
      +I    ; 
      L     #s_Item_Info[6].Position; 
      +I    ; 
      T     #s_Abs_Pos_First_Item; 
      JU    OA99; 

// Section 5
OA03: L     #s_Item_Info[5].Number_Items_Found; 
      L     0; 
      >I    ; 
      JCN   OA04; 

      L     #s_DB_PLT_Info[8].Conveyor_Length; 
      L     #s_DB_PLT_Info[7].Conveyor_Length; 
      +I    ; 
      L     #s_DB_PLT_Info[6].Conveyor_Length; 
      +I    ; 
      L     #s_Item_Info[5].Position; 
      +I    ; 
      T     #s_Abs_Pos_First_Item; 
      JU    OA99; 

// Section 4
OA04: L     #s_Item_Info[4].Number_Items_Found; 
      L     0; 
      >I    ; 
      JCN   OA05; 

      L     #s_DB_PLT_Info[8].Conveyor_Length; 
      L     #s_DB_PLT_Info[7].Conveyor_Length; 
      +I    ; 
      L     #s_DB_PLT_Info[6].Conveyor_Length; 
      +I    ; 
      L     #s_DB_PLT_Info[5].Conveyor_Length; 
      +I    ; 
      L     #s_Item_Info[4].Position; 
      +I    ; 
      T     #s_Abs_Pos_First_Item; 
      JU    OA99; 

// Section 3
OA05: L     #s_Item_Info[3].Number_Items_Found; 
      L     0; 
      >I    ; 
      JCN   OA06; 

      L     #s_DB_PLT_Info[8].Conveyor_Length; 
      L     #s_DB_PLT_Info[7].Conveyor_Length; 
      +I    ; 
      L     #s_DB_PLT_Info[6].Conveyor_Length; 
      +I    ; 
      L     #s_DB_PLT_Info[5].Conveyor_Length; 
      +I    ; 
      L     #s_DB_PLT_Info[4].Conveyor_Length; 
      +I    ; 
      L     #s_Item_Info[3].Position; 
      +I    ; 
      T     #s_Abs_Pos_First_Item; 
      JU    OA99; 

// Section 2
OA06: L     #s_Item_Info[2].Number_Items_Found; 
      L     0; 
      >I    ; 
      JCN   OA07; 

      L     #s_DB_PLT_Info[8].Conveyor_Length; 
      L     #s_DB_PLT_Info[7].Conveyor_Length; 
      +I    ; 
      L     #s_DB_PLT_Info[6].Conveyor_Length; 
      +I    ; 
      L     #s_DB_PLT_Info[5].Conveyor_Length; 
      +I    ; 
      L     #s_DB_PLT_Info[4].Conveyor_Length; 
      +I    ; 
      L     #s_DB_PLT_Info[3].Conveyor_Length; 
      +I    ; 
      L     #s_Item_Info[2].Position; 
      +I    ; 
      T     #s_Abs_Pos_First_Item; 
      JU    OA99; 

// Section 1 (most upstream)
OA07: L     #s_Item_Info[1].Number_Items_Found; 
      L     0; 
      >I    ; 
      JCN   OA08; 

      L     #s_DB_PLT_Info[8].Conveyor_Length; 
      L     #s_DB_PLT_Info[7].Conveyor_Length; 
      +I    ; 
      L     #s_DB_PLT_Info[6].Conveyor_Length; 
      +I    ; 
      L     #s_DB_PLT_Info[5].Conveyor_Length; 
      +I    ; 
      L     #s_DB_PLT_Info[4].Conveyor_Length; 
      +I    ; 
      L     #s_DB_PLT_Info[3].Conveyor_Length; 
      +I    ; 
      L     #s_DB_PLT_Info[2].Conveyor_Length; 
      +I    ; 
      L     #s_Item_Info[1].Position; 
      +I    ; 
      T     #s_Abs_Pos_First_Item; 
      JU    OA99; 

OA08: L     #s_Total_Conveyor_Length; 
      T     #s_Abs_Pos_First_Item; 

OA99: NOP   0; 
NETWORK
TITLE =PA:Calculation TOP
//The TOP (total occupied position) is a sum of all the item founded on each 
//sections 
      L     #s_Item_Info[1].Number_Items_Found; 
      L     #s_Item_Info[2].Number_Items_Found; 
      +I    ; 
      L     #s_Item_Info[3].Number_Items_Found; 
      +I    ; 
      L     #s_Item_Info[4].Number_Items_Found; 
      +I    ; 
      L     #s_Item_Info[5].Number_Items_Found; 
      +I    ; 
      L     #s_Item_Info[6].Number_Items_Found; 
      +I    ; 
      L     #s_Item_Info[7].Number_Items_Found; 
      +I    ; 
      L     #s_Item_Info[8].Number_Items_Found; 
      +I    ; 
      T     #o_TOP; 
NETWORK
TITLE =QA:Calculation TEP
//
//
      NOP   0; 
// Gap added to average baggage length
      L     #i_CFG_Gap; 
      L     #i_CFG_Avg_Bag_Length; // Average baggage length [cm]
      +I    ; 
      T     #s_Window_Length; 

      A     #o_ST_Operational_On; //IF LSZ operational on  
      AN    #s_Start_Flush_Memory; 
      AN    #s_LSZ_Full; 
      JCN   QA01; 

      L     #s_Abs_Pos_First_Item; // THEN calculation TEP
      L     #s_Window_Length; 
      /D    ; 
      T     #o_TEP; 
      JU    QA99; 
QA01: L     0; // ELSE force TEP to 0
      T     #o_TEP; 

QA99: NOP   0; 
NETWORK
TITLE =RA: Determining LSZ is Full
//When the bag reaches end of the section of Last section, then it will give the 
//LSZ full status & Give the disable send to the In-feed section.
//LSZ full status will be retained until zone is completely empty.
      L     #i_CFG_Run_Out_Distance; 
      A     #i_CFG_PTO; 
      JCN   RA01; 
      OPN   DB [#t_Most_Downstream_PLT_NO]; 
      L     DBW   12; 
RA01: NOP   0; 
      T     #t_Window_Full; 

      L     #t_Most_Downstream_PLT_NO; // If section PLT-DB is zero jump to end of the network
      L     0; 
      <>I   ; 
      JCN   RA99; 
//- Searching-up in runout distance from the EOS of Last sectio, if a leading edge is found then LSZ is full
      CALL "FC_PLT_Srch_Inf_Up" (
           i_DB_PLT_Num             := #t_Most_Downstream_PLT_NO,
           i_Position               := 0,
           i_Window                 := #t_Window_Full,
           i_Info                   := 1,
           o_Position               := #t_Not_Used_Int,
           o_Info                   := #t_Info_last_Sec,
           o_LNK                    := #t_Not_Used_Int,
           o_DB_PLT_Num             := #t_Not_Used_Int,
           o_Number_Items_Found     := #t_Not_Used_Int);

//Set the LSZ is full
      A(    ; 
      L     #t_Info_last_Sec; //Leading edge bag information of the Last section
      L     1; 
      ==I   ; 
      )     ; 
      S     #s_LSZ_Full; //SET LSZ Full

//Reseting the LSZ is full 
      A     #o_ST_LSZ_Empty; 
      R     #s_LSZ_Full; //RESET LSZ Full

//Status of the LSZ full
      A     #s_LSZ_Full; 
      AN    #s_Start_Flush_Memory; 
      A     #o_ST_Operational_On; 
      =     #o_ST_LSZ_Full; //OUTPUT LSZ Full

RA99: NOP   0; 
NETWORK
TITLE =SA: Determining LSZ is Empty
//If there are no bags found on the entire lane storage zone, then it gives 
//status 
//LSZ Empty.
      L     #o_TOP; 
      L     0; 
      <=I   ; 
      A     #s_Start_Flush_Memory; 
      FP    #s_FP_Down_Esave_Run; 
      JCN   SA01; 

      CALL "FC_PLT_Write" (
           i_DB_PLT_Num             := #s_DB_PLT_nr_Most_Downst,
           i_Position               := #s_Most_Down_Con_Len,
           i_Info_State             := W#16#0,
           i_Info_Physical          := -3,
           i_LNK                    := 0,
           i_DB_Event_Num           := #t_DB_Event_Num);

SA01: NOP   0; 

      CALL "FC_PLT_Srch_Inf_Up" (
           i_DB_PLT_Num             := #s_DB_PLT_nr_Most_Downst,
           i_Position               := 0,
           i_Window                 := #s_Most_Down_Con_Len,
           i_Info                   := 1,
           o_Position               := #t_Not_Used_Int,
           o_Info                   := #t_Not_Used_Int,
           o_LNK                    := #t_Not_Used_Int,
           o_DB_PLT_Num             := #t_Not_Used_Int,
           o_Number_Items_Found     := #s_Most_Down_Lead_Found);

      CALL "FC_PLT_Srch_Inf_Up" (
           i_DB_PLT_Num             := #s_DB_PLT_nr_Most_Downst,
           i_Position               := 0,
           i_Window                 := #s_Most_Down_Con_Len,
           i_Info                   := 2,
           o_Position               := #t_Not_Used_Int,
           o_Info                   := #t_Not_Used_Int,
           o_LNK                    := #t_Not_Used_Int,
           o_DB_PLT_Num             := #t_Not_Used_Int,
           o_Number_Items_Found     := #s_Most_Down_Trail_Found);


//If No Leading and Trailing Edge after extra conveyor Length run 
      AN(   ; 
      L     #s_Most_Down_Lead_Found; //   If there are no leading items
      L     0; 
      >I    ; 
      )     ; 
      AN(   ; 
      L     #s_Most_Down_Trail_Found; // But there are trailing items
      L     0; 
      >I    ; 
      )     ; 
      A(    ; 
      L     #o_TOP; 
      L     0; 
      <=I   ; 
      )     ; 
      AN    #s_Most_Down_Mtr_Run; 
      =     #o_ST_LSZ_Empty; 

NETWORK
TITLE =TA: Output of the LSZ on configured capacity
//Here it will calculate head to head according to the configured through put and 
//Maintain the flow of bags according to the calculated head to head distance 
//between the bags.
//FC_CALC_H2H_Distance: calculate the head to head distance depends on the Speed 
//and configured through put.
//
//FB_Flow_control: depend on the calculated head to head distance it will give 
//flow ok, depend on the Flow ok  status we can maintain the through-put.
      L     #s_DB_PLT_nr_Most_Downst; // If section PLT-DB is zero jump to end of the network
      L     1; 
      >I    ; 
      JCN   TA99; 

//---Checking the Head to head length 
      OPN   DB [#t_Most_Downstream_PLT_NO]; 
      A     DBX   10.1; 
      =     #t_Last_Sec_Motor_Run; //Section1 Motor run

      A     #i_CFG_PTO; 
      JCN   TA01; 

      L     750; 
      T     #t_Conveyor_Speed; 

      JU    TA02; 

TA01: L     500; 
      T     #t_Conveyor_Speed; 

TA02: CALL #s_FB_Flow_control (
           i_DB_PLT_Num             := #s_DB_PLT_nr_Most_Downst,
           i_Act_Run_Out_Distance   := #i_CFG_Run_Out_Distance,
           i_Act_Start_Up_Distance  := #i_CFG_Start_Up_Distance,
           i_CFG_Start_Up_Distance  := #i_CFG_Start_Up_Distance,
           i_Minimum_Gap            := 30,
           i_Add_Gap_Stop           := 0,
           i_Minimum_Head_To_Head   := #i_Minimum_H2H,
           i_Add_Head_To_Head_Stop  := 0,
           i_CFG_Conveyor_Speed     := #t_Conveyor_Speed,
           i_Section_Run            := #t_Last_Sec_Motor_Run,
           o_Flow_Control_Run_OK    := #t_Flow_Ok,
           o_Gap_Control_OK         := #t_Not_Used_bool,
           o_Head_to_Head_OK        := #t_Not_Used_bool);

TA99: NOP   0; 
NETWORK
TITLE =UA: Handling flush command
//When we receive Flush command One shot pulse from High level control, set the 
//static bit (s_Start_Flush_Memory) for memory & reset the Static bit
//(s_Start_Flush_Memory) when the LSZ completely empty.
      NOP   0; 
//---Reset the Flush memory when Lane is empty
//---Reset when the stop command is active
      A     #s_Start_Flush_Memory; 
      A     #o_ST_LSZ_Empty; 
      A(    ; 
      AN    #o_TRS1_CMD_Req_Run; 
      AN    #o_TRS2_CMD_Req_Run; 
      AN    #o_TRS3_CMD_Req_Run; 
      AN    #o_TRS4_CMD_Req_Run; 
      AN    #o_TRS5_CMD_Req_Run; 
      AN    #o_TRS6_CMD_Req_Run; 
      AN    #o_TRS7_CMD_Req_Run; 
      AN    #o_TRS8_CMD_Req_Run; 
      )     ; 
      O     #s_Disable_Command; 
      O     #s_Disable_Error; 
      AN    #i_Action_Active; 
      R     #s_Start_Flush_Memory; 

//---Set the Flush memory on one shot pulse---//
      A     #i_CMD_Start_Flush; 
      AN    #s_Disable_Error; 
      AN    #s_Disable_Command; 
      S     #s_Start_Flush_Memory; 

//Enable/Disbale  and Enable Release Request Evaluations

      A     #i_Stopped; 
      S     #s_Stopped; 

      A     #i_LSZ_All_Sec_Started; 
      AN    #s_Stopped; 
      O     #s_Stopped; 
      R     #s_Disable_Error; 

      AN    #i_LSZ_All_Sec_Started; 
      AN    #s_Stopped; 
      S     #s_Disable_Error; 

      A     #i_LSZ_All_Sec_Started; 
      AN    #i_Stopped; 
      R     #s_Stopped; 

      A     #i_CMD_Disable_Lane; 
      AN    #i_CMD_Enable_Lane; 
      S     #s_Disable_Command; 

      A     #i_CMD_Enable_Lane; 
      AN    #i_CMD_Disable_Lane; 
      R     #s_Disable_Command; 

      A     #s_Disable_Error; 
      O     #s_Disable_Command; 
      AN    #i_Action_Active; 
      =     #o_ST_Lane_Disabled; 

      A(    ; 
      A     #s_Disable_Error; 
      FN    #s_FN_Disable; 
      )     ; 
      O(    ; 
      A     #s_Disable_Command; 
      FN    #s_FN_Disable_Command; 
      )     ; 
      AN    #o_ST_Lane_Disabled; 
      S     #o_Enable_Release_Req; 

      A     #s_Start_Flush_Memory; 
      O     #o_ST_Lane_Disabled; 
      R     #o_Enable_Release_Req; 
NETWORK
TITLE =VA: Executing the Flush command 
//If flush command active then it will set the Request 
//run, Reset energy save to the LSZ out-feed section and activate all the 
//sections 
//of the LSZ, so that all bags will be emptying according to configured 
//throughput.
//On the Negative edge of the flush command:-
//If handover active is True on the last section then it will memorise and 
//run all the section until last section handover active is False. (This is done 
//because to avoid the LSZ handover fault) Then it will reset Request run and de-
//activate all the section of the LSZ.
//
      NOP   0; 
//---------------Handling Flush command on active----------------------//
      A     #s_Start_Flush_Memory; // Flush command 
      A     #i_LSZ_All_Sec_Started; 

      S     #o_LSZ_Outfeed_Rst_ESave; // Reset the Energy save of the LSZ downstream
      S     #o_ST_LSZ_Emptying; //Set the Flushing
      R     #s_FN_Stop_Req_Run; 

      A     #s_Start_Flush_Memory; 
      A     #o_ST_Operational_On; 
      A     #t_Flow_Ok; 
      =     #s_Flush_Req_Run; // Set the Request Run

//---------------------Handling Flush command on Negative Edge-----------------------------//
      A     #s_Start_Flush_Memory; // Flush command 
      FN    #s_FN_Flush; 
      =     #s_FN_Flush_Memory; //set on Negative edge flush Memory

      A     #s_FN_Flush_Memory; //If Negative edge flush memory is active
      ON    #i_LSZ_All_Sec_Started; 
      R     #o_TRS1_CMD_Req_Run; //Then reset the Run output TRS1
      R     #o_TRS2_CMD_Req_Run; //Then reset the Run output TRS2
      R     #o_TRS3_CMD_Req_Run; //Then reset the Run output TRS3
      R     #o_TRS4_CMD_Req_Run; //Then reset the Run output TRS4
      R     #o_TRS5_CMD_Req_Run; //Then reset the Run output TRS5
      R     #o_TRS6_CMD_Req_Run; //Then reset the Run output TRS6
      R     #o_TRS7_CMD_Req_Run; //Then reset the Run output TRS7
      R     #o_TRS8_CMD_Req_Run; //Then reset the Run output TRS8
      R     #o_LSZ_Outfeed_Rst_ESave; // Reset the Energy save command for the LSZ downstream.
      R     #s_FP_Flush_Memory; //Then reset the Positive edge Flush memory
      R     #o_ST_LSZ_Emptying; //Reset Flushing

NETWORK
TITLE =WA: Handling Handover fault on Infeed section
//On flush command active if handover active is True on the In-feed section then 
//it will memorise and run the section until In-feed section handover active is 
//False.  
      L     #s_DB_PLT_Info[1].DB_PLT_Number; // If section PLT-DB is zero jump to end of the network
      L     1; 
      >I    ; 
      JCN   WA99; 

//---Preparing the Handover active in the Infeed section--------//
//---Searching for the Leading edge of the bag in Runout distance
      CALL "FC_PLT_Srch_Inf_Dwn" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[1].DB_PLT_Number,
           i_Position               := #s_DB_PLT_Info[1].Conveyor_Length,
           i_Window                 := #i_CFG_Run_Out_Distance,
           i_Info                   := 1,
           o_Position               := #t_Not_Used_Int,
           o_Info                   := #t_Not_Used_Int,
           o_LNK                    := #t_Not_Used_Int,
           o_DB_PLT_Num             := #t_Not_Used_Int,
           o_Number_Items_Found     := #t_Infeed_Num_Items_Found);

      L     #t_Infeed_Num_Items_Found; 
      L     0; 
      >I    ; 
      S     #s_Infeed_Handover_Active; 


//---Searching for the Trailing edge of the bag in Runout distance
      CALL "FC_PLT_Srch_Inf_Dwn" (
           i_DB_PLT_Num             := #s_DB_PLT_Info[1].DB_PLT_Number,
           i_Position               := #s_DB_PLT_Info[1].Conveyor_Length,
           i_Window                 := #i_CFG_Run_Out_Distance,
           i_Info                   := 2,
           o_Position               := #t_Not_Used_Int,
           o_Info                   := #t_Not_Used_Int,
           o_LNK                    := #t_Not_Used_Int,
           o_DB_PLT_Num             := #t_Not_Used_Int,
           o_Number_Items_Found     := #t_Infeed_Num_Items_Found);

      L     #t_Infeed_Num_Items_Found; 
      L     0; 
      >I    ; 
      R     #s_Infeed_Handover_Active; 

      A     #s_Start_Flush_Memory; // flush command
      FP    #s_FP_Flush; 
      S     #s_FP_Flush_Memory; 

      A     #s_FP_Flush_Memory; 
      A     #s_Infeed_Handover_Active; 
      =     #s_Infeed_HandOvr_Fault; 

      A     #s_Start_Flush_Memory; 
      AN    #s_Infeed_Handover_Active; 
      R     #s_FP_Flush_Memory; 
WA99: NOP   0; 
NETWORK
TITLE =XA: Resetting the Output according to the number of section
//      It will make sure that only configured numbers of section outputs are 
//high.
      NOP   0; 
// Calculation number of sections in the LSZ 
      L     #s_Info_Loop_Nr; 
      L     1; 
      +I    ; 
      T     #s_Num_of_Sections; 

      L     #s_Num_of_Sections; //IF Number of section in LSZ is equal to 1 then jump to the label
      L     1; 
      <>I   ; 
      JCN   XA01; 

      L     #s_Num_of_Sections; //IF Number of section in LSZ is equal to 2 then jump to the label
      L     2; 
      <>I   ; 
      JCN   XA02; 

      L     #s_Num_of_Sections; //IF Number of section in LSZ is equal to 3 then jump to the label
      L     3; 
      <>I   ; 
      JCN   XA03; 

      L     #s_Num_of_Sections; //IF Number of section in LSZ is equal to 4 then jump to the label
      L     4; 
      <>I   ; 
      JCN   XA04; 

      L     #s_Num_of_Sections; //IF Number of section in LSZ is equal to 5 then jump to the label
      L     5; 
      <>I   ; 
      JCN   XA05; 

      L     #s_Num_of_Sections; //IF Number of section in LSZ is equal to 6 then jump to the label
      L     6; 
      <>I   ; 
      JCN   XA06; 

      L     #s_Num_of_Sections; //IF Number of section in LSZ is equal to 7 then jump to the label
      L     7; 
      <>I   ; 
      JCN   XA07; 

      L     #s_Num_of_Sections; //IF Number of section in LSZ is equal to 8 then jump to the label
      L     8; 
      <>I   ; 
      JCN   XA99; 

      JU    XA99; //IF Number of section in LSZ is not between 1 to 8 then jump to the label

XA01: CLR   ; 
      =     #s_TRS2_Activate; //Then reset the Activate TRS2
      =     #s_TRS3_Activate; //Then reset the Activate TRS3
      =     #s_TRS4_Activate; //Then reset the Activate TRS4
      =     #s_TRS5_Activate; //Then reset the Activate TRS5
      =     #s_TRS6_Activate; //Then reset the Activate TRS6
      =     #s_TRS7_Activate; //Then reset the Activate TRS1
      =     #s_TRS8_Activate; //Then reset the Activate TRS8
      =     #o_TRS2_CMD_Req_Run; //Then reset the Run output TRS2
      =     #o_TRS3_CMD_Req_Run; //Then reset the Run output TRS3
      =     #o_TRS4_CMD_Req_Run; //Then reset the Run output TRS4
      =     #o_TRS5_CMD_Req_Run; //Then reset the Run output TRS5
      =     #o_TRS6_CMD_Req_Run; //Then reset the Run output TRS6
      =     #o_TRS7_CMD_Req_Run; //Then reset the Run output TRS7
      =     #o_TRS8_CMD_Req_Run; //Then reset the Run output TRS8
      JU    XA99; 

XA02: CLR   ; 
      =     #s_TRS3_Activate; //Then reset the Activate TRS3
      =     #s_TRS4_Activate; //Then reset the Activate TRS4
      =     #s_TRS5_Activate; //Then reset the Activate TRS5
      =     #s_TRS6_Activate; //Then reset the Activate TRS6
      =     #s_TRS7_Activate; //Then reset the Activate TRS1
      =     #s_TRS8_Activate; //Then reset the Activate TRS8
      =     #o_TRS3_CMD_Req_Run; //Then reset the Run output TRS3
      =     #o_TRS4_CMD_Req_Run; //Then reset the Run output TRS4
      =     #o_TRS5_CMD_Req_Run; //Then reset the Run output TRS5
      =     #o_TRS6_CMD_Req_Run; //Then reset the Run output TRS6
      =     #o_TRS7_CMD_Req_Run; //Then reset the Run output TRS7
      =     #o_TRS8_CMD_Req_Run; //Then reset the Run output TRS8
      JU    XA99; 

XA03: CLR   ; 
      =     #s_TRS4_Activate; //Then reset the Activate TRS4
      =     #s_TRS5_Activate; //Then reset the Activate TRS5
      =     #s_TRS6_Activate; //Then reset the Activate TRS6
      =     #s_TRS7_Activate; //Then reset the Activate TRS1
      =     #s_TRS8_Activate; //Then reset the Activate TRS8
      =     #o_TRS4_CMD_Req_Run; //Then reset the Run output TRS4
      =     #o_TRS5_CMD_Req_Run; //Then reset the Run output TRS5
      =     #o_TRS6_CMD_Req_Run; //Then reset the Run output TRS6
      =     #o_TRS7_CMD_Req_Run; //Then reset the Run output TRS7
      =     #o_TRS8_CMD_Req_Run; //Then reset the Run output TRS8
      JU    XA99; 

XA04: CLR   ; 
      =     #s_TRS5_Activate; //Then reset the Activate TRS5
      =     #s_TRS6_Activate; //Then reset the Activate TRS6
      =     #s_TRS7_Activate; //Then reset the Activate TRS1
      =     #s_TRS8_Activate; //Then reset the Activate TRS8
      =     #o_TRS5_CMD_Req_Run; //Then reset the Run output TRS5
      =     #o_TRS6_CMD_Req_Run; //Then reset the Run output TRS6
      =     #o_TRS7_CMD_Req_Run; //Then reset the Run output TRS7
      =     #o_TRS8_CMD_Req_Run; //Then reset the Run output TRS8
      JU    XA99; 

XA05: CLR   ; 
      =     #s_TRS6_Activate; //Then reset the Activate TRS6
      =     #s_TRS7_Activate; //Then reset the Activate TRS7
      =     #s_TRS8_Activate; //Then reset the Activate TRS8
      =     #o_TRS6_CMD_Req_Run; //Then reset the Run output TRS6
      =     #o_TRS7_CMD_Req_Run; //Then reset the Run output TRS7
      =     #o_TRS8_CMD_Req_Run; //Then reset the Run output TRS8
      JU    XA99; 

XA06: CLR   ; 
      =     #s_TRS7_Activate; //Then reset the Activate TRS7
      =     #s_TRS8_Activate; //Then reset the Activate TRS8
      =     #o_TRS7_CMD_Req_Run; //Then reset the Run output TRS7
      =     #o_TRS8_CMD_Req_Run; //Then reset the Run output TRS8
      JU    XA99; 

XA07: CLR   ; 
      =     #s_TRS8_Activate; //Then reset the Activate TRS8
      =     #o_TRS8_CMD_Req_Run; //Then reset the Run output TRS8
      JU    XA99; 

XA99: NOP   0; 
NETWORK
TITLE =YA: Reporting status to the HLC
//Status is reported on Priority basis:-
//Priority-1. Out of service 
//Priority-2. Safety Stop
//Priority-3. Lane is Full (Temporary not available)
//Priority-4. Emptying (Flushing)
//Priority-5. Operational ok & Ready to store the bags on the lane.
//
//If Configured report time(i_CFG_HLC_Report_Time) is more than "0" then status is
// 
//reported on configured time interval.
//If Configured report time(i_CFG_HLC_Report_Time) is "0" then status is reported 
//on status change.
      L     #i_CFG_HLC_Report_Time; // Load the HLC report time
      L     0; 
      ==I   ; 
      JCN   YA01; 
      R     #s_HLC_Report_Time_Active; 
      JU    YA05; 

YA01: AN    #s_HLC_Report_Time_Active; 
      A(    ; 
      L     #s_HLC_Report_Time; // transfer to the memory
      L     0; 
      ==I   ; 
      )     ; 
      JCN   YA02; 

      L     #i_CFG_HLC_Report_Time; // Load the HLC report time
      T     #s_HLC_Report_Time; // transfer to the memory

YA02: A     "M_OS_/1.0_sec."; 
      JCN   YA05; 
      L     #s_HLC_Report_Time; 
      L     1; 
      -I    ; // THEN delay counter := delay counter 
      JPZ   YA03; 

// If below zero, then set back at zero
      L     0; 
YA03: T     #s_HLC_Report_Time; 

      L     #s_HLC_Report_Time; // If the delay time is zero
      L     0; 
      <=I   ; 
      JCN   YA04; //If it more than zero than jump to the label

      SET   ; // Then cascade delay is done ready to run the motor
      =     #s_HLC_Report_Time_Active; 
      JU    YA05; 

YA04: CLR   ; 
      =     #s_HLC_Report_Time_Active; 

//-- Priority -1
YA05: A(    ; 
      AN    #o_ST_Operational_On; //Reporting on Time base
      )     ; 
      A     #i_Safety_OK; 
      A     #s_HLC_Report_Time_Active; 
      O(    ; 
      A     #o_ST_Operational_On; //Reporting on Status change
      FN    #s_FN_Operation_On; 
      A     #i_Safety_OK; 
      )     ; 
      JCN   YA21; 
      L     4; //Reporting "OUT OF SERVICE"
      T     #t_EBS_Lane_State; 
      JU    YA20; 

//-- Priority -2
YA21: AN    #i_Safety_OK; 
      JCN   YA11; 

      L     4; // Reporting "OUT OF SERVICE"
      T     #t_EBS_Lane_State; 
      JU    YA20; 

//-- Priority -3
YA11: A     #o_ST_LSZ_Full; //Reporting on Time base
      A     #s_HLC_Report_Time_Active; 
      O(    ; 
      A     #o_ST_LSZ_Full; //Reporting on Status change
      FP    #s_FP_LSZ_Full; 
      )     ; 
      JCN   YA12; 
      L     3; //Reporting "LSZ FULL" Temporary Not Available
      T     #t_EBS_Lane_State; 
      JU    YA20; 

//-- Priority -4
YA12: A     #o_ST_LSZ_Emptying; //Reporting on Time base
      A     #s_HLC_Report_Time_Active; 
      O(    ; 
      A     #o_ST_LSZ_Emptying; //Reporting on Status change
      FP    #s_FP_LSZ_Emptying; 
      )     ; 
      JCN   YA13; 
      L     2; //Reporting "EMPTYING" Flushing
      T     #t_EBS_Lane_State; 
      JU    YA20; 

//-- Priority -5
YA13: A     #o_ST_Operational_On; //Reporting on Time base
      AN    #o_ST_LSZ_Full; 
      AN    #o_ST_LSZ_Emptying; 
      A     #s_HLC_Report_Time_Active; 
      O(    ; 
      A     #o_ST_Operational_On; //Reporting on Status change
      AN    #o_ST_LSZ_Full; 
      AN    #o_ST_LSZ_Emptying; 
      FP    #s_FP_Operation_On; 
      )     ; 
      JCN   YA99; 
      L     1; //Reporting "OPERATIONAL" Ready to recieve the Bag
      T     #t_EBS_Lane_State; 
      JU    YA20; 

YA20: A     #s_HLC_Report_Time_Active; //IF HLC time interval expires
      O(    ; //OR
      L     #t_EBS_Lane_State; //Present EBS Lane State
      L     #s_Prev_Segment_State; //Last report EBS Lane State
      <>I   ; //NOT-EQUAL  Report the EBS Lane State to the DB-Event
      )     ; 
      JCN   YA99; 

//------------HLC REPORTING-------------//
      CALL "FC_Write_Event" (//Report the EBS Lane State to the DB_Event
           i_Message_ID             := 1404,//EBS Lane Status Report
           i_Event_value            := #t_EBS_Lane_State,
           i_DB_Event_Num           := #t_DB_Event_Num,
           o_Return_Value           := #t_Return_Value);

      L     #t_EBS_Lane_State; 
      T     #s_Prev_Segment_State; 

      CLR   ; 
      =     #s_HLC_Report_Time_Active; 

YA99: NOP   0; 
NETWORK
TITLE =ZA:Create Availablity Report

      A     #o_ST_Operational_On; 
      FP    #s_FP_Operational_Active; 
      =     #t_OS_FP_Oper_Active; 

      A     #o_ST_Operational_On; 
      FN    #s_FN_Operational_Active; 
      =     #t_OS_FN_Oper_Active; 

      AN    #s_Time_Elapsed_AvaiRep; 
      AN    #t_OS_FP_Oper_Active; 
      AN    #t_OS_FN_Oper_Active; 
      =     #t_StartTimerModereq; 

      CALL "FC_On_Dly_Timer_Sec" (
           i_CMD_Start              := #t_StartTimerModereq,
           i_CFG_Timer_Value        := 30,
           i_Setpoint               := #s_TimeSpoint_AvaiRep,
           o_Setpoint               := #s_TimeSpoint_AvaiRep,
           o_Timer_Elapsed          := #s_Time_Elapsed_AvaiRep);


      A     #t_OS_FP_Oper_Active; 
      O     #t_OS_FN_Oper_Active; 
      O     #s_Time_Elapsed_AvaiRep; 
      JCN   ZA99; 

      L     0; 
      A     #o_ST_Operational_On; 
      JCN   ZA01; 
      L     1; 
ZA01: T     #t_Available_Value; 

      CALL "FC_Write_Event" (//Report the EBS Lane State to the DB_Event
           i_Message_ID             := 1221,//Availabilty Report
           i_Event_value            := #t_Available_Value,
           i_DB_Event_Num           := #t_DB_Event_Num,
           o_Return_Value           := #t_Return_Value);

ZA99: NOP   0; 
END_FUNCTION_BLOCK

